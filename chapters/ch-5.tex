\chapter{Aggregate Commit with Verification} % (fold)
\label{cha:A Protocol for Commitment Tree Generation}
	
	\textcolor{red}{Motivation:}
	SHIA helps the sensor node verify that its original sensor reading was aggregated correctly or not by an aggregator.
	If an aggregator has tampered with the original sensor reading reported by the sensor node then the sensor node can report the problem.
	But SHIA does not help detecting and removing the malicious aggregator from the network.
	We develop the protocol which helps identify the malicious aggregator in the network.
	% which is built on top of commitment tree generation of SHIA mentioned in the previous chapter.

\section{Signing the Data-Item}
	\begin{definition}
		\label{def:data-item}
		A commitment tree is a binary tree where each vertex has an associated data-item representing the data that is passed on to its parent. The data-items have the following format:

		$\hspace{100pt}$ $<$id, count, value, commitment$>$
	\end{definition}
	Where id is the unique ID of the node; count is the number of leaf vertices in the subtree rooted at this vertex; value is the SUM aggregate computed over all the leaves in the subtree and commitment is a cryptographic commitment.
	There is one vertex $s_{0}$ for each sensor node $s$, which we call the leaf vertex of $s$ Equation \ref{eq:leaf-vertex} and associated signature to it Equation \ref{eq:signature-leaf-vertex}.
	\begin{equation}
		\label{eq:leaf-vertex}
		s_{0}\ =\ <s_{id}, 1, s_{value}, H(N||1||s_{value})>
	\end{equation}
	\begin{equation}
		\label{eq:signature-leaf-vertex}
		Sign(s_{0}) = E_{K_{s}}(H(s_{0}))
	\end{equation}
	In addition to sending the data-item, each sensor node sends the signature of the data-item to its parent.
	The parent node verifies its child's signature using it's certificate.
	After verification of signature it proceeds with the aggregation.
	
\section{Signing the Commitment Payload}
		We define commitment payload based on the commitment forest Defined in \ref{def:commitment-forest}.
	\begin{definition}
		A \textbf{commitment payload} is a set of data-items of the root vertices of the trees in the outgoing commitment forest.
	\end{definition}
	% We use the term payload for commitment payload and the term forest for the commitment forest.
	For brevity, we use the term forest, payload instead of commitment forest, commitment payload respectively.

	In addition to the sending all the data-items with their respective signatures, an intermediate node sends an additional signature to its parent, which is a signature of all the data-items in its commitment forest.
	This additional signature signifies the following:
	\begin{itemize}
		\item	An intermediate sensor node has verified all the data-items in its forest.
		\item An intermediate sensor node can not claim sending different data-items to its parent in the future.
		\item From the parent or ancestor node perspective, it has received all the verified data-items from its children and not from anywhere else.
		\item The parent or ancestor node can not claim receiving different data-item form its children in the future.
	\end{itemize}
	% Each sensor node signs all the data-items in its commitment payload before sending it to its parent.
	% to prove the fact that it has verified all the data-items in its commitment forests.
	For example, for the aggregation tree shown in Figure \ref{fig:Palm aggregation tree}, the payload of sensor node $C$ is show in Figure \ref{fig:commitment-tree-example-1}.
			\begin{figure}[h!]
				\centering
				\includegraphics[scale = 0.5]{images/palm-aggregation-tree.png}\\
				\caption{Palm aggregation tree}
				\label{fig:Palm aggregation tree}
			\end{figure}
		% $C$ receives $B_{1}$, $Sign(B_{1})$ from $B$.
		% And $C$'s commitment forest is show in Figure \ref{fig:Commitment forest of C}.
		% $B_{1} = <B_{id}, 2, B_{value}, H(N||2||B_{value}||A_{0}||B_{0})>$; $Sign(B_{1}) = E_{K_{B}}(H(B_{1}))$\\
		% 	\begin{figure}[h!]
		% 		\centering
		% 		\includegraphics[scale = 0.5]{images/commitment-forest-of-C.png}\\
		% 		\caption{$C$'s commitment forest }
		% 		\label{fig:Commitment forest of C}
		% 	\end{figure}\\
		The sensor node $C$ sends all the data-items in its payload with their signatures to $D$.
		Furthermore, $C$ sends the signature of its payload $Sign(C_{p})$ to $D$.\\
		$B_{1} =\ <B_{id}, 2, B_{value}, H(N||2||B_{value}||A_{0}||B_{0})>$; $Sign(B_{1}) = E_{K_{B}}(H(B_{1}))$\\
		$C_{0} =\ <C_{id}, 1, C_{value}, H(N||1||C_{value})>$; $Sign(C_{0}) = E_{K_{C}}(H(C_{0}))$\\
		\textcolor{red}{$Sign(C_{p}) =\	E_{K_{C}}(H(C_{0} || B_{1}))$}
			\begin{figure}[h!]
				\centering
				\includegraphics[scale = 0.5]{images/commitment-payload-of-C.png}
				\caption{$C$'s commitment commitment-payload}
				\label{fig:Commitment payload of C}
			\end{figure}
	% Sending an additional signature with all the data-items signifies that a sensor node has verified all the data-items.
	% The basic idea is that the sensor node signs all the data-items it sends to its parent.
	% \textbf{Because of the signature, the sensor node has the proof for the sent data-item.
	% It also prevents the parent or ancestor node from claiming the different received data-item.}

	\section{Commitment Tree Generation}
	For the given aggregation tree the commitment forest is built as follows.
	Leaf sensor nodes in the aggregation tree create their leaf vertex and their respective signatures according to Equation \ref{eq:leaf-vertex}, \ref{eq:signature-leaf-vertex} which they send it to their parent in the aggregation tree.
	Each internal sensor node $I$\ in the aggregation tree also creates their leaf vertex and signature.
	In addition, $I$\ receives the payload from each of its children which creates the forest for $I$.
	Once $I$ verifies all the received signatures, it merges all the data-items in its forest with same count value to form its payload.

	Suppose $I$ have to create its payload by merging $i$ data-items $D_{1}$, $D_{2}$, $\dotsc$, $D_{i}$ in its forest.
	First $I$ verifies the received signatures $Sign(D_{1})$, $Sign(D_{2})$, $\dotsc$, $Sign(D_{i})$.
	Once verified $I$ starts merging the data-items.
	Let $c$ be the smallest count value in $I$'s forest.
	The sensor node $I$ finds two data-items $D_{1},D_{2}$ in its forest with the same count value $c$ and merges them into a new data-item with the count of $c+1$.
	\textcolor{red}{add figure}
	It repeats the process until no two data-items in its forest have the same count value.
	An example of generating the payload by merging the data-items in the forest for the sensor node $A$ in Figure \ref{fig:at} is illustrated in the following example.
	% \ref{fig:commitment-tree-example-1}, \ref{fig:commitment-tree-example-2}, \ref{fig:commitment-tree-example-3}, \ref{fig:commitment-tree-example-4}.
			\begin{exmp} The commitment-payload generation process for node $A$ of Figure \ref{fig:at} is shown here.\\
				\begin{figure}[h!]
					\centering
					\includegraphics[scale = 1]{images/commitment-tree-example-1.png}\\
					\caption{$A$ receives $C_{2}$ from $C$, $(B_{1},B_{0})$ from $B$, $D_{0}$ from $D$ and generates $A_{0}$. The commitment payload received from a given sensor node is indicated by dashed-line box.}
					\label{fig:commitment-tree-example-1}
				\end{figure}\\
				$A_{0} = <A_{id}, 1, A_{value}, H(N||1||A_{value})>$; $Sign(A_{0}) = E_{K_{A}}(H(A_{0}))$ \\
				$D_{0} = <D_{id}, 1, D_{value}, H(N||1||D_{value})>$; $Sign(D_{0}) = E_{K_{D}}(H(D_{0}))$\\
				$B_{0} = <B_{id}, 1, B_{value}, H(N||1||B_{value})>$; $Sign(B_{0}) = E_{K_{B}}(H(B_{0}))$\\
				$B_{1} = <B_{id}, 2, B_{value}, H(N||2||B_{value}||E_{0}||F_{0})>$; $Sign(B_{1}) = E_{K_{B}}(H(B_{1}))$\\
				\textcolor{red}{$Sign(B_{P}) = E_{K_{B}}(H(B_{0} || B_{1}))$}\\
				$C_{2} = <C_{id}, 4, C_{value}, H(N||4||C_{value})||H_{1}||C_{1})>$; $Sign(C_{2}) = E_{K_{C}}(H(C_{2}))$\\
				\begin{figure}[h!]
					\centering
					\includegraphics[scale = 1]{images/commitment-tree-example-2.png}\\
					\caption{First Merge: $A_{1}$ vertex created by A.}
					\label{fig:commitment-tree-example-2}
				\end{figure}\\
				$A_{1} = <A_{id}, 2, A_{1value}, H(N||2||A_{1value}||A_{0}||D_{0})>$; $Sign(A_{1}) = E_{K_{A}}(H(A_{1}))$\\
				where $A_{1value} = A_{value} + D_{value} $
				\begin{figure}[h!]
					\centering
					\includegraphics[scale = 1]{images/commitment-tree-example-3.png}\\
					\caption{Second Merge: $A_{2}$ vertex created by A.}
					\label{fig:commitment-tree-example-3}
				\end{figure}\\
				$A_{2} = <A_{id}, 4, A_{2value}, H(N||4||A_{2value}||B_{1}||A_{1}) >$; $Sign(A_{2}) = E_{K_{A}}(H({A_{2}}))$\\
				where $A_{2value} = B_{1value} + A_{1value} $
				\begin{figure}[h!]
					\centering
					\includegraphics[scale = 1]{images/commitment-tree-example-4.png}\\
					\caption{Third Merge: $A_{3}$ vertex created by A.}
					\label{fig:commitment-tree-example-4}
				\end{figure}\\
				$A_{3} = <A_{id},8, A_{3value},H(N||8||A_{3value}||C_{2}||A_{2})>$; $Sign(A_{3}) = E_{K_{A}}(H(A_{3}))$\\
				$A_{3value} = A_{2value} + C_{2value}$;
			\end{exmp}
% chapter A Protocol for Commitment Tree Generation (end)

% Talk about the certificates:
	
% 	How many certificates does $A$ need to know in this example ?
% 	In the above example, $A$ need to know $D,B,C's$ certificate to verify their signatures.
% 	But if we use SHIA'a approach of creating commitment tree then $A$ need to know $E's$ certificate as well.
% 	Hence, being root in as many tree as possible is the more efficient.
	
\section{Bandwidth Analysis}
	An intermediate sensor node $S$ with $n$ descendants has at most $\log(n)$ commitment trees in its forest and at most $(\log(n) + 1)$ data-items in its payload with at most $(\log(n) +2)$ signatures.
	Computation cost: Needs to calculate that many signatures. Needs to verify that many signatures.
	Need to know that many certificates.