\chapter{Data Aggregation Without Internal Verification} % (fold)
	\label{cha:Data Aggregation Without Internal Verification}

	Secure hierarchical in-network aggregation (SHIA) \cite{chan2006secure} presents the first and provably secure sensor network data aggregation protocol without internal verification.
	It is designed for general networks with single or multiple adversaries.
	Our work enhances SHIA, by making it communication efficient, adds new security services to the protocol, achieves similar security goals with non-resilient aggregation functions and efficient ways of analyzing the protocol.
	In this chapter, we summarize the important parts of SHIA and relevant terms, to build the foundation to describe our protocol in the following chapters.
	% SHIA computes the aggregate functions (such as $\textit{truncated SUM}$, $\textit{AVERAGE}$, $\textit{COUNT}$, $\Phi-QUANTILE$) of the sensor readings.
	% For example, a network with $5$ nodes having the following sensor readings $10,11,8,15,12$ has the overall all sum of $56$, the average of $11.2$ and the median ($\Phi = 0.5$) of $11$.
	% The goal of the SHIA is to compute the aggregate functions while assuming that partially a network is controlled by an adversary which is attempting to skew the final aggregated result.

\section{Network Assumptions}
	We assume a multi hop network with a set $ S = \{S_{1},...,S_{n}\} $ of $n$ sensor nodes where all sensor nodes are alive and reachable. 
	The network is organized in a rooted tree topology.
	The trusted base station resides outside of the network and has more computation, storage capacity then the sensor nodes in the network. 
	\textbf{Note}: SHIA names the base station as the querier and the root of the tree as the base station. 
	The base station knows total number of sensor nodes in the network and the network topology. 
	It also has the capacity to directly communicate with every sensor node in the network using authenticated broadcast.
	All the wireless communications between the nodes are peer-to-peer and we do not consider the local wireless broadcast.
	Each sensor node $S$ has a unique ID and shares a unique secret symmetric key $K_{S}$ with the base station.
	The keys enable message authentication between sensor node and the base station.
	And it also allows encryption if the data confidentiality is required.
	All the sensor nodes are capable of doing symmetric key encryption and symmetric key decryption.
	They are also capable of computing collision resistant cryptographic hash function. 

\section{Attacker Model And Security Goal}
	We consider a model with a polynomially bounded adversary of \cite{przydatek2003sia}, which has a complete control over some of the sensor nodes in the network.
	Most significantly, the adversary can change the measured values reported by sensor nodes under its control.
	An adversary can perform a wide variety of attacks.
	For example, an adversary could report fictitious values (probably completely independent of the measured reported values), instead of the real aggregate values and the base station receives the fictitious aggregated information. 
	Since in many applications the information received by the base station provides a basis for critical decisions, false information could have ruinous consequences as described in Section \ref{sec:security-issues}.
	However, we do not want to limit ourselves to just a few specific selected adversarial models. 
	Instead, we assume that the adversary can misbehave in any arbitrary way, and the only limitations we put on the adversary are its computational resources (polynomial in terms of the security parameter) and the fraction of nodes that it can have control over. 
	We focus on \textbf{stealthy attacks} \cite{przydatek2003sia}, where the goal of an adversary is to make the base station accept false aggregation results, which are significantly different from the true results determined by the measured values, while not being detected by the base station.
	In this setting, denial-of-service (DoS) attacks such as not responding to the queries or always responding with negative acknowledgment at the end of verification phase clearly indicates to the base station that something is wrong in the network and therefore is not a stealthy attack.
	One of the security goals of SHIA is to detect the stealthy attacks.
	And one of the security goals of our work is to detect an adversary who caused the stealthy attacks and remove it from the network to prevent these attacks in the future.
	
% \section{Security Goal}
	Without precise knowledge of application, the direct data injection attacks are indistinguishable from the malicious sensor readings.
	The goal of SHIA is to design an \textbf{optimally secure} aggregation algorithm with only \textbf{sublinear edge congestion}.
	\begin{definition}
		\label{def:optimally-secure}
		\cite{chan2006secure} An aggregation algorithm is \textbf{optimally secure} if, by tampering with the aggregation process, an adversary is unable to induce the base station to accept any aggregation result which is not already achievable by direct data injection.
	\end{definition}

\section{The SUM Aggregate Algorithm of SHIA}
		In this algorithm, the aggregate function $f$\ is summation meaning that we want to compute $a_{1} + a_{2} + \dotsc + a_{n}$, where $a_{i}$\ is the reading of the sensor node $i$.
		The algorithm has the following three main phases.
		\begin{description}
			\item [Query dissemination,] initiates the aggregation process.
			\item [Aggregate commit,] initiates the commitment tree generation process.
			\item [Result checking,] initiates the distributed, interactive verification process.
		\end{description}

\section{Query Dissemination}
	\label{sec:query-dissemination}
	Prior to this phase, an aggregation trees is created using a tree generation algorithm.
	We can use any tree generation algorithm as this protocol works on any aggregation tree structure.
	For completeness of this protocol, one can use Tiny Aggregation Service (TaG)\cite{madden2002tag}.
	TaG uses broadcast message from the base station to initiate a tree generation.
	Each node selects its parent from whichever node it first receives the tree formation message.
	One possible aggregation tree for given network graph in Figure \ref{fig:ng} is shown in Figure \ref{fig:at}. 
	\begin{figure}[h!]
		\centering
		\includegraphics[scale = 1]{images/network-graph.png}
		\caption{Network graph}
		\label{fig:ng}
	\end{figure}

	To initiate the query dissemination phase, the base station broadcasts the query request message with the query nonce $N$\ in the aggregation tree. 
	The query request message contains new query nonce $N$\ for each query.
	The fresh nonce is used for each new query to prevent replay attacks in the network.
	SHIA uses \textbf{hash chain} to generate new nonce for each query. 
	A hash chain is constructed by repeatedly evaluating a pre-image resistant hash function $h$\ on some initial random value, the final value (or ``anchor value'') is preloaded on the nodes in the network.
	The base station uses the pre-image of the last used  value as the nonce for the next broadcast.
	For example, if the last known value of the hash chain is $h^i(X)$, then the next broadcast uses $h^{i-1}(X)$ as the nonce; $X$ is the initial random value.
	When a node receives a new nonce $N^{'}$, it verifies that $N^{'}$ is a precursor to the most recently received (and authenticated) nonce $N$ on the hash chain, i.e., $h^{i}(N^{'}) = N$ for some $i$ bounded by a fixed $k$ of number of hash applications.  
	A hash chain prevents an adversary from predicting the query nonce for future queries as it has to reverse the hash chain computation to get an acceptable pre-image.
	\begin{figure}[h!]
		\centering
		\includegraphics[scale = 1]{images/aggregation-tree.png}
		\caption{Simplified Aggregation tree for network graph in Figure \ref{fig:ng}}
		\label{fig:at}
	\end{figure}		

\section{Aggregate Commit} 
	% (fold)
	\label{sub:aggregate_commit}
	The aggregate commit phase constructs cryptographic commitments to the data values and to the intermediate aggregated data-values.
	These commitments are then passed on to the base station by the root of an aggregation tree.
	The base station then rebroadcasts the commitments to the sensor network using an authenticated broadcast so that the rest of the sensor nodes in the network can verify that their respective data values have been incorporated into the final aggregate value.
	The commitment tree is a logical tree built on top of an aggregation tree.
	The commitment tree is defined as follows:
	\begin{definition}
		\cite{chan2006secure}
		A commitment tree is a tree where each vertex has an associated label representing the data that is passed on to its parent. The labels have the following format:

		$\hspace{100pt}$ $<$count, value, complement, commitment$>$\\
		where count is the number of leaf vertices in the subtree rooted at this vertex; value is the SUM aggregate computed over all the leaves in the subtree; complement is the aggregate over the COMPLEMENT of the data values; and commitment is a cryptographic commitment.
		\label{def:label}
	\end{definition}
	The sensor node $A$ creates the label for the leaf vertex $A_{0}$ is given as follows :
	\begin{equation}
		A_{0} =\ <A_{count}, A_{value}, \overline{A_{value}}, A_{commitment}>
	\end{equation}
	where $A_{value}$ is the sensor data collected by $A$, $\overline{A_{value}}$ = $r - A_{value}$ with $r$ being the upper bound on allowable data values.
	The values of $A_{count} = 1$, and $A_{commitment}$ = $A_{id}$ which is unique ID of $A$ as $A_{0}$ is the leaf vertex of $A$.
	Internal vertices in the commitment tree represent aggregation operations, and have labels that are defined based on their children. 
	Suppose an internal node $I$ has child vertices with the following labels : $A_{1}$, $A_{2}$, $\dotsc$ , $A_{q}$, where $A_{i}$ = $<$ $A_{icount}$, $A_{ivalue}$, $\overline{A_{ivalue}}$, $A_{icommitment}$$>$. 
	The label for the internal vertex $I_{j}$ is given as follows:
	\begin{equation}
		\begin{array}{l}
			I_{j} =\ <I_{jcount}, I_{jvalue}, \overline{I_{jvalue}}, I_{jcommitment}>\\
			I_{jcount} = \sum A_{icount}\\ 
			I_{jvalue} = \sum A_{ivalue}\\
			\overline{I_{jvalue}} = \sum \overline{A_{ivalue}}\\
			I_{jcommitment} = H[N||I_{jcount}||I_{jvalue}||\overline{I_{jvalue}}||A_{1}||A_{2}|| \dotsc ||A_{q}]\\
		\end{array}
	\end{equation}
	The word vertex is used for the node in the commitment tree and the node is used for the node in the aggregation tree.
	There is a mapping between the node in the aggregation tree and the vertices in the commitment tree.
	A vertex is a logical element in the commitment tree where as the node is a physical sensor node which does all the local computations and wireless communications.
	The commitment field in the label is calculated using collision resistant hash function which makes impossible for an adversary to change the commitment structure once it is sent to the base station.
	% Our payload format is compact than the label format which is discussed in the next chapter.

	\subsection{Aggregate Commit: Naive Approach}
	% (fold)
		\label{sub:aggregate_commit_naive_approach}
		In the naive approach, during aggregation process each sensor node computes a cryptographic hash of all its inputs (including its own data value).
		The aggregation result along with the hash value called a label, is then passed on to the parent in the aggregation tree.
		Conceptually, a commitment tree is a logical tree built on top of an aggregation tree, with additional aggregate information attached to the nodes. 
		% , to help in the result checking phase.
		% The label is format is described in Definition \ref{def:label}.
		The commitment tree for the aggregation tree of Figure \ref{fig:at} is  shown in Figure \ref{fig:naive-commitment-tree} .
		In this example, the node $B$ receives $E_{0}$ from $E$, $F_{0}$ from $F$ and has its own leaf vertex $B_{0}$.
		The node $B$ aggregates all three vertices by creating a new vertex $B_{1}$ and sends $B_{1}$ to its parent node $A$.
		The label of an internal vertex $B_{1}$ is defined as follows:
		\begin{equation}
			B_{1} =\ <3, B_{1value}, \overline{B_{1value}}, H[N || 3 || B_{1value} || \overline{B_{1value}} ||B_{0}||E_{0}||F_{0}]>\\
		\end{equation}
		The labels of the vertices on the path of node $I$ to the root for the commitment tree $A$ are given as follows:
		\begin{equation}
			\begin{array}{l}
				I_{0} =\ <1, I_{value}, \overline{I_{value}}, I_{id}>\\
				H_{1} =\ <2, H_{1value}, \overline{H_{1value}}, H [ N || 2 || H_{1value} || \overline{H_{1value}} || H_{0} || I_{0} ] > ; H_{1value} = I_{value} + H_{value}\\
				B_{1} =\ <3, B_{1value}, \overline{B_{1value}}, H [ N || 3 || B_{1value} || \overline{B_{1value}} || B_{0} || E_{0} || F_{0} ] > ; \\ 
				B_{1value} = B_{value} + E_{value} + F_{value} \\
				C_{1} =\ <4, C_{1value}, \overline{C_{1value}}, H [ N || 4 || C_{1value} || \overline{C_{1value}} || C_{0} || G_{0} || H_{1} ] > \\
				C_{1value} = C_{value} + G_{value} + H_{1value} \\
				A_{1} =\ <9, A_{1value}, \overline{A_{1value}}, H [ N || 9 || A_{1value} || \overline{A_{1value}} || A_{0} || D_{0} || B_{1} || C_{1} ] >\\
				A_{1value} = A_{value} + D_{value} + B_{1value} + C_{1value} \\
			\end{array}
		\end{equation}
		\begin{figure}[h!]
			\centering
			\includegraphics[scale = 1]{images/naive-commitment-tree.png}
			\caption{Naive commitment tree for Figure \ref{fig:at}. For each sensor node $S$, $S_{0}$ is its leaf vertex, while $S_{1}$ is the internal vertex representing the aggregate computation at $S$ (if any). The internal vertices are represented by dashed box.}
			\label{fig:naive-commitment-tree}
		\end{figure}
		In the naive approach the information rate is $1/n$ where $n$ is the number of children for the given node.
		As each node aggregates all the labels into one label before sending it to the parent node.  
	\subsection{Aggregate Commit: Improved Approach} 
	% (fold)
		\label{sub:aggregate_commit_improved_approach}
		The aggregation tree is a subgraph of the network graph so it may be randomly unbalanced.
		This approach tries to separate the structure of the commitment tree from the structure of the aggregation tree.
		So, the commitment tree can be perfectly balanced.
		In the naive approach, each sensor node always computes the aggregate sum of all its inputs which is a greedy approach.
		SHIA uses delayed aggregation approach, which performs an aggregation operation if and only if it results in a complete, binary commitment tree.

		We now describe SHIA's delayed aggregation algorithm for producing balanced commitment trees.
		In the naive commitment tree, each sensor node passes to its parent a single message containing the label of the root vertex of its commitment subtree $T_{s}$.
		In the delayed aggregation algorithm, each sensor node passes on the labels of the root vertices of a set of commitment subtrees $F = \{ T_{1}, \dotsc, T_{q} \}$.
		We call this set a commitment forest, and we enforce the condition that the trees in the forest must be complete binary trees, and no two trees have the same height. 
		These constraints are enforced by continually combining equal-height trees into complete binary trees of greater height.
		\begin{definition}
			\cite{chan2006secure}
			\label{def:commitment-forest}
			A commitment forest is a set of complete binary commitment trees such that there is at most one commitment tree of any given height.
		\end{definition}
		The commitment forest is built as follows. 
		Leaf nodes in the aggregation tree originate a single-vertex commitment forest, which they then communicate to their parent nodes. Each internal node $I$ originates a similar single-vertex commitment forest.
		In addition, $I$ also receives commitment forests from each of its children.
		The node $I$ keeps track of which root vertices were received from which of its children.
		It then combines all the forests to form a new forest as follows.
		Suppose $I$ wishes to combine $q$ commitment forests $F_{1}$,$\dotsc$,$F_{q}$.
		Note that since all commitment trees are complete binary trees, tree heights can be determined by inspecting the count field of the root vertex.
		We let the intermediate result be $F$ $=$ $F_{1}$ $\cup$ $\dotsc$ $\cup$ $F_{q}$, and repeat the following until no two trees are the same height in $F$.
		Let $h$ be the smallest height such that more than one tree in $F$ has height $h$.
		Find two commitment trees $T_{1}$ and $T_{2}$ of height $h$ in $F$, and merge them into a tree of height $h + 1$ by creating a new vertex that is the parent of both the roots of $T_{1}$ and $T_{2}$ according to the inductive rule in Definition \ref{def:label}.
		The following example illustrates the commitment tree generation process for the node $A$ of Figure \ref{fig:at}.
		\begin{figure}[h!]
			\includegraphics{images/commitment-tree-example-1-shia.png}
			\caption{$A$ receives $C_{2}$ from $C$, $(B_{1},B_{0})$ from $B$, $D_{0}$ from $D$ and generates $A_{0}$. The commitment forest received from a given sensor node is indicated by dashed-line box.}
			\label{fig:commitment-tree-example-1-shia}
		\end{figure}
		\begin{equation}
			\begin{array}{l}
				A_{0} = <1, A_{value}, \overline{A_{value}}, A_{id}>\\
				D_{0} = <1, D_{value}, \overline{D_{value}}, D_{id}>\\
				E_{0} = <1, E_{value}, \overline{E_{value}}, E_{id}>\\
				B_{1} = <2, B_{1value}, \overline{B_{1value}}, H(N || 2 || B_{1value} || \overline{B_{1value}} || B_{0} || F_{0})>\\
				C_{2} = <4, C_{2value}, \overline{C_{2value}}, H(N || 4 || C_{2value} || \overline{C_{2value}} || H_{1} || C_{1})>\\
			\end{array}
		\end{equation}
		\begin{figure}[h!]
			\centering
			\includegraphics{images/commitment-tree-example-2-shia.png}
			\caption{First Merge: $A_{1}$ vertex created by A.}
			\label{fig:commitment-tree-example-2-shia}
		\end{figure}
		\begin{equation}
			\begin{array}{l}
				A_{1} =\  < 2, A_{1value}, \overline{A_{1value}}, H(N || 2 || A_{1value}|| \overline{A_{1value}} || A_{0} || D_{0})>\\
				A_{1value} =\  A_{value} + D_{value};\ \overline{A_{1value}} = \overline{A_{value}} + \overline{D_{value}}
			\end{array}
		\end{equation}
		\begin{figure}[h!]
			\centering
			\includegraphics{images/commitment-tree-example-3-shia.png}
			\caption{Second Merge: $A_{2}$ vertex created by A.}
			\label{fig:commitment-tree-example-3-shia}
		\end{figure}
		\begin{equation}
			\begin{array}{l}
				A_{2} = <4, A_{2value}, \overline{A_{2value}}, H(N || 4 || A_{2value} || \overline{A_{2value}} || B_{1} ||A_{1}) >\\
				A_{2value} = A_{1value} + B_{1value};\ \overline{A_{2value}} = \overline{A_{1value}} + \overline{B_{1value}}
			\end{array}
		\end{equation}
		\begin{figure}[h!]
			\centering
			\includegraphics{images/commitment-tree-example-4-shia.png}
			\caption{Third Merge: $A_{3}$ vertex created by A.}
			\label{fig:commitment-tree-example-4-shia}
		\end{figure}
		\begin{equation}
			\begin{array}{l}
				A_{3} = <8, A_{3value}, \overline{A_{3value}}, H(N || 8 || A_{3value} || \overline{A_{3value}} || C_{2} ||A_{2}) >\\
				A_{3value} = A_{2value} + C_{2value};\ \overline{A_{3value}} = \overline{A_{2value}} + \overline{C_{2value}}
			\end{array}
		\end{equation}
		
		Once the base station has received the final commitment forest from the root node, it checks that none of the SUM or COMPLEMENT aggregates of the roots of the trees in the forest are negative. 
		If any aggregates are negative, the base station rejects the result and raises an alarm: a negative aggregate is a sure sign of tampering since all the data values (and their complements) are non-negative. 
		Otherwise, the base station then computes the final pair of aggregates SUM and COMPLEMENT. 
		The base station verifies that SUM + COMPLEMENT = $nr$ where $r$ is the upper bound on the range of allowable data values on each node. 
		If this verifies correctly, the base station then initiates the result checking phase.

\section{Result Checking} % (fold)
	\label{sec:result_checking}
	SHIA presents novel distributed verification algorithm, achieving provably optimal security while maintaining sublinear edge congestion.
	In our work, we take similar approach and add new capabilities to help find an adversary.
	Here, we describe the SHIA's result checking phase to build the basis for our work.

	The purpose of the result checking phase is to enable each sensor node $I$ to independently verify that its data value ($I_{value}$) was added into the SUM aggregate, and the complement $\overline{I_{value}}$ of its data value was added into the COMPLEMENT aggregate.
	First, the base station sends the aggregation results from the aggregation commit phase to every sensor node in the network using authenticated broadcast.
	Each sensor node then individually verifies that its contributions to the respective SUM and COMPLEMENT aggregates were indeed counted.
	If so, it sends an authentication code to the base station.
	The authentication code is also aggregated for communication efficiency. 
	When the base station has received all the authentication codes, it is then able to verify that all sensor nodes have checked that their contribution to the aggregate has been correctly counted.
	The result checking process has the following phases.

	\begin{description}
		\item[Distributing Final Commitment Values]
			In this phase, the base station sends each of the received commitment labels to the entire network using authenticated broadcast.
			Authenticated broadcast means that each sensor node can verify that the message was sent by the base station and no one else.
		\item[Distributing Off-path Values]
			Each vertex must receive all of its off-path values to do the verification.
			The off-path values are defined as follows.
			\begin{definition}
				\label{def:off-path}
				\cite{chan2006secure}
				The set of off-path vertices for a vertex $u$ in a tree is the set of all the siblings of each of the vertices on the path from $u$ to the root of the tree that $u$ is in (the path is inclusive of $u$).
			\end{definition}
			\begin{figure}[h!]
				\centering
				\includegraphics[scale = 1]{images/off-path.png}
				\caption{Off-path vertices of $u$ are highlighted in bold.}
				\label{fig:commitment-tree-example-2-shia}
			\end{figure}
			Vertex receives its off-path values from its parent.
			Each internal vertex has two children.
			For example, an internal vertex $k$\ has two children $k_{1},k_{2}$.
			$k$\ sends the label of $k_{1}$\ to $k_{2}$\ and vice versa.
			$k$\ tags the relevant information of its left and right child.
			Once a vertex receives all of its off-path values it begins the verification phase.
		\item[Verification of Contribution]
			In this phase, the leaf vertex calculates the root vertex's label using its own label and off-path vertex labels received from its parent.
			It compares the the calculated root vertex's label with the label received from the base station.
			If those two labels match then it proceeds to the next step with Acknowledgment (ACK) message or with Negative Acknowledgment (NACK) message.
			This allows the leaf to verify that its label was not modified on the path to the root during the aggregation commit phase.
		\item[Collection of Authentication Codes] 
			Once each sensor node verifies its contribution to the root label it sends the relevant authentication code to its parent.
			The authentication code for sensor node $A$\ with ACK and NACK message is given as follows :
			\begin{equation}
				\begin{array}{l}
					\mbox{MAC}_{S_{A}}( \mbox{N} || \mbox{ACK})\\
					\mbox{MAC}_{S_{A}}( \mbox{N} || \mbox{NACK})	
				\end{array}
			\end{equation}
			Where ACK, NACK are unique message identifier for positive and negative acknowledgment respectively, 
			MAC is  the message authentication algorithm, 
			N is the query nonce and $S_{A}$\ is secret key that node $A$\ shares with the base station.
			Collection of authentication code starts with the leaf nodes in the aggregation tree.
			Leaf nodes in the aggregation tree send their authentication codes to their parent.
			Once the parent node has received the authentication from all of its children it does XOR operation on all the authentication codes including its own authentication code and sends it to its parent in the aggregation tree hierarchy.
			Each internal node in the aggregation tree repeats the process.
			Finally, the root of an aggregation tree sends a single authentication code to the base station which is an XOR of all the authentication codes of the aggregation tree.  
		\item[Verification of confirmations]
			Since the base station shares the secret key of all the nodes in the network, it computes the following:
			\begin{equation}
				\bigoplus_{i = 1}^n \mbox{MAC}_{S_{i}}(\mbox{N} || \mbox{ACK})
			\end{equation}
			Then it compares the computed code with the received code. 
			If those two codes match, then the base station accepts the aggregation result.
	\end{description}

	\begin{theorem}
		\cite{chan2006secure}
		Let the final SUM aggregate received by the base station be $S$.
		If the base station accepts $S$, then $S_{L} \leq S \leq (S_{L} + \mu \cdot r)$ where $S_{L}$ is the sum of the data values of all the legitimate nodes, $\mu$ is the total number of malicious nodes, and $r$ is the upper bound on the range of allowable values on each node.
	\end{theorem}
	The proof for the above theorem is given in \cite{chan2006secure}.
	The theorem gives the proof of correctness of the SHIA protocol.
	It proves that if the final aggregated value is accepted by the base station then it has to be in the given range. 
	Hence, SHIA achieves security over the Truncated SUM which is a resilient aggregator according to Wagner\cite{wagner2004resilient}.
	Our protocol enhances SHIA to achieve desired security over the SUM which is non-resilient aggregate.
% section result_checking (end)