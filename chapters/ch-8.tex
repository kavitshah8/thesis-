\chapter{Forwarding Signatures With Resigning Data-Items (FS\lowercase{w}RD)}
	In this chapter, we describe our protocol from the query dissemination phase till the detecting an adversary using forwarding the signatures with resigning the data-items approach.

\section{Query Dissemination}
	The protocol begins with the base station initiating the query request to the sensor network.
	The base station does the authenticated broadcast of its query to the entire sensor network asking the network to report the aggregated result of the sensor reading values.
	It includes the query nonce in its query to avoid replay attacks in the future. 
	We use the same hash chain process to generate unique query nonce for the base station as described in Section \ref{sec:query-dissemination}.
	Once the sensor nodes receive the query from the base station they creates their own leaf vertex by creating the data-items of their sensor readings and its signature.
	The sensor nodes create their payloads and send it to their parent in the aggregation tree. 
	The details of the commitment tree generation is described in the next section.

\section{Commitment Tree Generation}
	For the given aggregation tree the commitment forest is built as follows.
	The commitment tree generation begins from the sensor nodes with the highest depth (leaf nodes) in the aggregation tree.
	Leaf sensor nodes in the aggregation tree create their leaf vertex by creating data-items, signatures of those data-items and signature of the \textcolor{red}{transmit-payload} according to Equation \ref{eq:data-item}, \ref{eq:sign-data-item}, \ref{eq:signing-payload} respectively.
	And then send the payload to their parents in the aggregation tree.	
	Each internal sensor node in the aggregation tree also creates their leaf vertex.
	In addition, internal sensor node receives the payload from each of its children which creates the forest for it.
	For all of its children, internal node first verifies the signature of the transmit-payload and then the signature of the data-item for one child at a time.
	Once internal node verifies all the received signatures, it merges all the data-items in its forest with same count value.
	It merges two data-items by creating a new data-item with count value incremented by one and whose value is the addition of value field of the previous two data-items. 
	Note that we can easily determine the height of the commitment tree from the count value.
	Suppose, after verifying all the signatures from the payloads, an internal sensor node $I$ has to merge $i$ data-items $D_{1}$, $D_{2}$, $\dotsc$, $D_{i}$ in its forest.
	% First, $I$ verifies all the received payload signatures.
	% Then $I$ verifies the received signatures $Sign(D_{1})$, $Sign(D_{2})$, $\dotsc$, $Sign(D_{i})$.
	% Once verified, $I$ starts merging the data-items as follows.
	Let $c$ be the smallest count value in $I$'s forest.
	The sensor node $I$ finds two data-items $D_{1},D_{2}$ in its forest with the same count value $c$ and merges them into a new data-item with the count of $c+1$ as shown in Figure \ref{fig:increase-height}.
	\begin{figure}[h!]
		% \centering
		\includegraphics{images/increase-height.png}
		\caption{$A$ has $B_{1}, C_{1}$ in his forest and aggregates those two trees and creates $A_{2}$.}
		\label{fig:increase-height}
	\end{figure}
	It repeats the process until no two data-items in its forest have the same count value.	
	The data-item of the $A_{2}$ is given as follows:
	\begin{equation}
		A_{2} = <A_{id}, 4, A_{2value},H(N||4||A_{2value}||B_{1}||D_{1})>;\ A_{2value} = B_{1value} + D_{1value} 
	\end{equation}
	
	We demonstrate the commitment tree generation process for the aggregation tree shown in Figure \ref{fig:Aggregation-tree-1}.
		\begin{figure}[h!]
			\centering
			\includegraphics{images/aggregation-tree-1.png}
			\caption{Aggregation Tree.}
			\label{fig:Aggregation-tree-1}
		\end{figure}
		In this example, $A$ has three children. $A$ receives one payload from each of its children which creates $A$'s forest.
		After verifying all the signatures from its forest, $A$ uses the data-items in its forest to create its payload, which is sent to the base station.
		First, we describe the payload generation process of $B,C,D$ and then for $A$.

		The sensor node $B$ creates its payload from its forest. 
		It's forest consists of payloads received from $E,F$.
		The leaf sensor nodes $E,F$ creates their payloads according to Equation \ref{eq:signing-payload} as follows:
		% \begin{figure}[h!]
		% 	\centering
		% 	\includegraphics{images/e-payload.png}
		% 	\caption{E's payload}
		% 	\label{fig:e-payload}
		% \end{figure}
		\begin{equation}
			\begin{array}{l}
			E_{p} =\ <E_{0}, \textsf{Sign}_{S_{E}}(E_{0}), \textsf{Sign}_{S_{E}}(E_{\tau}) >\ where\ E_{\tau} =\ <E_{0}>\\
			E_{0} =\ <E_{id}, 1, E_{value}, H(N||1||E_{value})>
			\end{array}
		\end{equation}
		% \begin{figure}[h!]
		% 	\centering
		% 	\includegraphics{images/f-payload.png}
		% 	\caption{F's payload}
		% 	\label{fig:f-payload}
		% \end{figure}
		\begin{equation}
			\begin{array}{l}
				F_{p} =\ <F_{0}, \textsf{Sign}_{S_{F}}(F_{0}), \textsf{Sign}_{S_{F}}(F{\tau}) >\ where\ F_{\tau} =\ <F_{0}>\\
				F_{0} =\ <F_{id}, 1, F_{value}, H(N||1||F_{value})>
			\end{array}
		\end{equation}
		$B$ receives $E_{p},F_{p}$ from $E,F$ respectively. 
		$B$ verifies all the signatures in the received payloads.
		Then it creates its own data-item $B_{0}$.
		Now, $B$ has $B_{0},E_{0},F_{0}$ in its forest as shown in Figure \ref{fig:b-forest-payload}. 
		As all the data-items have the same count value, $B$ has an option which two data-items to merge.
		$B$ aggregates $E_{0},F_{0}$ and creates $B_{1}$.
		After creating $B_{1}$ none of the data-items have the same count value. 
		So, $B$ creates its payload $B_{p}$ and sends it to $A$ as follows:
		\begin{equation}
			\begin{array}{l}
				B_{p} =\ < B_{0}, \textsf{Sign}_{S_{B}}(B_{0}), B_{1}, \textsf{Sign}_{S_{B}}(B_{1}), \textsf{Sign}_{S_{B}}(B_{\tau}) >\ where\ B_{\tau} =\ <B_{0} || B_{1}>\\
				B_{1} =\ < B_{id}, 2, B_{1value}, H(N||2||B_{1value}||E_{0}||F_{0})>;\ B_{1value} = E_{value} + F_{value} \\
				B_{0} =\ <B_{id}, 1, B_{value}, H(N||1||B_{value})>
			\end{array}
			\label{eq:b-payload}
		\end{equation}
		\begin{figure}[h!]
			\centering
			\includegraphics{images/b-forest-payload.png}
			\caption{Transformation from $B$'s forest to its payload.
			 				Each dashed-line box shows forest and solid-line box shows payload of the respective sensor node.}
			\label{fig:b-forest-payload}
		\end{figure}

		In similar way, the sensor node $C$ in the aggregation tree receives $G_{p}$ from $G$ which is defined as follows:
		\begin{equation}
			\begin{array}{l}
				G_{p} =\ <G_{1},\textcolor{red}{\textsf{Sign}_{S_{G}}(G_{1})}, \textsf{Sign}_{S_{G}}(G_{\tau})>\ where\ G_{\tau} =\ <G_{0} || H_{0}>\\
				G_{1} =\ < G_{id}, 2, G_{1value}, H(N||2||G_{1value}||G_{0}||H_{0})>;\ G_{1value} = G_{value} + H_{value} \\
				G_{0} =\ <G_{id}, 1, G_{value}, H(N||1||G_{value})>\\
				H_{0} =\ <H_{id}, 1, H_{value}, H(N||1||H_{value})>
			\end{array}
		\end{equation}
		$C$ verifies all the signatures in the received payload $G_{p}$ and creates $C_{0}$.
		Now, $C$ has $C_{0},G_{1}$ in its forest as shown in Figure \ref{fig:c-forest-payload}. 
		As none of the data-items have the same count value, $C$ does not merge those two data-items.
		But $C$ removes the old signature on $G_{1}$ and signs $G_{1}$ with its secret key.
		So, $C$ creates its payload $C_{p}$ and sends it to $A$ as follows:
		\begin{figure}[h!]
			\centering
			\includegraphics{images/c-forest-payload.png}
			\caption{$C$'s forest aggregation creating its payload.}
			\label{fig:c-forest-payload}
		\end{figure}
		\begin{equation}
			\begin{array}{l}
				C_{p} =\ <C_{0},\textsf{Sign}_{S_{C}}(C_{0}),G_{1},\textcolor{red}{\textsf{Sign}_{S_{C}}(G_{1})}, \textsf{Sign}_{S_{C}}(C_{\tau})>\ where\ C_{\tau} =\ <C_{0} || G_{1}>\\
				C_{0} =\ <C_{id}, 1, C_{value}, H(N||1||C_{value})>
			\end{array}
			\label{eq:c-payload}
		\end{equation}

		The sensor node $D$ creates its payload ($D_{p}$) and sends it to $A$ as follows:
		\begin{equation}
			\begin{array}{l}
				D_{p} =\ <D_{0}, \textsf{Sign}_{S_{D}}(D_{0}), \textsf{Sign}_{S_{D}}(D_{\tau})>;\ where\ D_{\tau} =\ <D_{0}>\\
				D_{0} =\ <D_{id},1,D_{value},H(N||1||D_{value})>
			\end{array}
			\label{eq:d-payload}
		\end{equation}

		The root node of the aggregation tree $A$ receives the payloads $B_{p}, C_{p}, D_{p}$
		% Equations \ref{eq:b-payload},\ref{eq:c-payload},\ref{eq:d-payload} 
		from $B,C,D$ respectively.
		$A$ verifies all the signatures in the received payloads and creates $A_{0}$.
		$A$ has $G_{1},C_{0},B_{1},B_{0},D_{0},A_{0}$ in its forest as shown in Figure \ref{fig:a-forest}.
		\begin{figure}[h!]
			\centering
			\includegraphics{images/a-forest.png}
			\caption{$A$'s forest: $A$ receives three payloads from $C,B,D$ and creates $A_{0}$}
			\label{fig:a-forest}
		\end{figure}
		\begin{figure}[h!]
			\centering
			\includegraphics{images/a-forest-first-merge.png}
			\caption{$A$'s forest: after first merge}
			\label{fig:a-forest-first-merge}
		\end{figure}
		\begin{figure}[h!]
			\centering
			\includegraphics{images/a-forest-second-merge.png}
			\caption{$A$'s forest: after second merge}
			\label{fig:a-forest-second-merge}
		\end{figure}
		$A$ has four data-items with count value of $1$.
		In the first merge, $A$ aggregates those data-items and creates $A_{10},A_{11}$ as shown in Figure \ref{fig:a-forest-first-merge}.
		Now, $A$ has four data-items with count value of $2$.
		In the second merge, $A$ aggregates those data-items and creates $A_{20},A_{21}$ as shown in Figure \ref{fig:a-forest-second-merge}.
		Finally, $A$ has two data-items with count value of $4$.
		In the final merge, $A$ aggregates those data-items and creates $A_{3}$ as shown in Figure \ref{fig:a-payload}.
		Then $A$ creates payload and sends it to the base station as follows:
		\begin{equation}
			\begin{array}{l}
				A_{p} =\ <A_{3},\textsf{Sign}_{S_{A}}(A_{3}),\textsf{Sign}_{S_{A}}(A_{\tau})>\ where\ A_{\tau} =\ <A_{3}>\\
				A_{3} =\ <A_{id}, 8, A_{3value}, H(N||8||A_{3value}||A_{20}||A_{21})>;\ A_{3value} =\ A_{20value} + A_{21value}\\
				A_{20} =\ <A_{id},4,A_{20value},H(N||4||A_{20value}||G_{1}||B_{1})>;\ A_{20value} =\ G_{1value} + B_{1value}\\ 
				A_{21} =\ <A_{id},4,A_{21value},H(N||4||A_{21value}||A_{10}||A_{11})>;\ A_{21value} =\ A_{10value} + A_{11value}\\ 
				A_{10} =\ <A_{id},2,A_{10value},H(N||2||A_{10value}||B_{0}||C_{0})>;\ A_{10value} =\ B_{value} + C_{value}\\
				A_{11} =\ <A_{id},2,A_{11value},H(N||2||A_{11value}||D_{0}||A_{0})>;\ A_{11value} =\ D_{value} + A_{value}\\
				A_{0} =\ <A_{id},1,A_{value},H(N||1||A_{value})>
			\end{array}
		\end{equation}
		\begin{figure}[h!]
			\centering
			\includegraphics{images/a-payload.png}
			\caption{$A$'s payload : $A$ sends this to the base station.}
			\label{fig:a-payload}
		\end{figure}

				% \begin{figure}[h!]
				% 	\centering
				% 	% \includegraphics[width=6in]{images/commitment-tree-example-1.png}\\
				% 	\caption{$A$ receives $C_{2}$ from $C$, $(B_{1},B_{0})$ from $B$, $D_{0}$ from $D$ and generates $A_{0}$. The commitment payload received from a given sensor node is indicated by dashed-line box.}
				% 	\label{fig:commitment-tree-example-1}
				% \end{figure}
				% \begin{equation}
				% 	\begin{array}{l}
				% 		A_{0} = <A_{id}, 1, A_{value}, H(N||1||A_{value})>; \textsf{Sign}_{S_{A}}(A_{0}) \\
				% 		D_{0} = <D_{id}, 1, D_{value}, H(N||1||D_{value})>; \textsf{Sign}_{S_{D}}(D_{0})\\
				% 		B_{0} = <B_{id}, 1, B_{value}, H(N||1||B_{value})>; \textsf{Sign}_{S_{B}}(B_{0})\\
				% 		B_{1} = <B_{id}, 2, B_{value}, H(N||2||B_{value}||E_{0}||F_{0})>; \textsf{Sign}_{S_{B}}(B_{1})\\
				% 		\textcolor{red}{\textsf{Sign}_{S_{B}}(B_{0} || B_{1}), benefits}\\
				% 		C_{2} = <C_{id}, 4, C_{value}, H(N||4||C_{value})||H_{1}||C_{1})>; \textsf{Sign}_{S_{C}}(C_{2})\\
				% 		\end{array}
				% \end{equation}

				% \begin{figure}[h!]
				% 	\centering
				% 	\includegraphics[width=6in]{images/commitment-tree-example-2.png}\\
				% 	\caption{First Merge: $A_{1}$ vertex created by A.}
				% 	\label{fig:commitment-tree-example-2}
				% \end{figure}

				% \begin{equation}
				% 	\begin{array}{l}
				% A_{1} = <A_{id}, 2, A_{1value}, H(N||2||A_{1value}||A_{0}||D_{0})>; \textsf{Sign}_{S_{A}}(A_{1})\\
				% where\  A_{1value} = A_{value} + D_{value} \\
				% 	\end{array}	
				% \end{equation}
				% \begin{figure}[h!]
				% 	\centering
				% 	\includegraphics[width=\textwidth]{images/commitment-tree-example-3.png}\\
				% 	\caption{Second Merge: $A_{2}$ vertex created by A.}
				% 	\label{fig:commitment-tree-example-3}
				% \end{figure}
				% \begin{equation}
				% 	\begin{array}{l}
				% 		A_{2} = <A_{id}, 4, A_{2value}, H(N||4||A_{2value}||B_{1}||A_{1}) >; \textsf{Sign}_{S_{A}}(A_{2})\\
				% 		where\  A_{2value} = B_{1value} + A_{1value} \\
				% 	\end{array}
				% \end{equation}
				% \begin{figure}[h!]
				% 	\centering
				% 	\includegraphics[width=6in]{images/commitment-tree-example-4.png}\\
				% 	\caption{Third Merge: $A_{3}$ vertex created by A.}
				% 	\label{fig:commitment-tree-example-4}
				% \end{figure}
				% \begin{equation}
				% 	\begin{array}{l}
				% 		A_{3} = <A_{id},8, A_{3value},H(N||8||A_{3value}||C_{2}||A_{2})>; \textsf{Sign}_{S_{A}}(A_{3})\\
				% 		where\ A_{3value} = A_{2value} + C_{2value}
				% 	\end{array}
				% \end{equation}

	Once the base station receives the payload from the root of the aggregation tree, it verifies all the signatures in the payload.
	In the previous example the base station receives $A_{p}$ from the sensor node $A$.
	It verifies the signatures $\textsf{Sign}_{S_{A}}(A_{3})$, $\textsf{Sign}_{S_{A}}(A_{\tau})$ in the received payload.	 
	If the base station verifies all the signatures to true it initiates the result checking phase.

\section{Result Checking}
	The purpose of the result checking phase is to enable all the sensor nodes to verify their individual contributions to the final aggregate value.
	If there is any inconsistency in the aggregation process then with the help of the base station, trace down the node responsible for causing the inconsistency in the aggregation process.

	\subsection{Dissemination Final Payload by the Base Station}
		Once the base station receives the payloads of the root node of the aggregation tree, it verifies all the signatures in the payload and then sends each of the data-items in the payload to the entire sensor network using authenticated broadcast.
		The authenticated broadcast allows the sensor nodes to verify that the data-items are sent by from the base station. 
		And no one else is masquerading the base station.
		In our previous example, the base station receives only one data-item $A_{3}$ in the payload sent by $A$.
		In that case, the base station's payload $\textsf{B}_{p}$ which is sent to the entire network is given as follows:
 		\begin{equation}
			\textsf{B}_{p} =\ <A_{3}, \textsf{Sign}_{S_{\textsf{B}}}(A_{3}), \textsf{Sign}_{S_{\textsf{B}}}(\textsf{B}_{\tau})>\ where\ \textsf{B}_{\tau} =\ <A_{3}>
		\end{equation}

	\subsection{Dissemination of Off-Path Values}
		To enable verification each sensor node must receive all of its off-path values.
		The off-path values of the sensor nodes can be determined according to the Definition \ref{def:off-path}.
		Each internal vertex $t$ in the commitment tree has two children $u1$ and $u2$. 
		To disseminate off-path values, $t$ sends the data-item of $u1$ to $u2$, and vice-versa ($t$ also attaches relevant information tagging $u1$ as the right child and $u2$ as the left child) along with the signatures of the data-item and the signature of the transmit-payload.
		In our previous example, internal vertex $A_{10}$ as shown in Figure \ref{fig:a-payload} has two children $C_{0},B_{0}$.
		$A_{10}$ sends the following off-path values to $C, B$ respectively as follows:
		\begin{equation}
			\begin{array}{l}
			<B_{0}, \textsf{Sign}_{S_{A}}(B_{0}),\textsf{Sign}_{S_{A}}(A_{\tau})>\ where\ A_{\tau} =\ <B_{0}>\\
			<C_{0}, \textsf{Sign}_{S_{A}}(C_{0}),\textsf{Sign}_{S_{A}}(A_{\tau})>\ where\ A_{\tau} =\ <C_{0}>
			\end{array}
		\end{equation}
		An internal vertex $t$ receives data-items with their respective signatures from its parent. 
		It verifies the signatures of the received data-items then resigns them and sends those data-items (and left/right tags) with their signatures to both of its children.
		Continuing the previous example, internal vertex $A_{10}$ receives $A_{11}, A_{20}$ form its parent $A_{21}$.
		$A_{10}$ sends the following off-path values to $C, B$ respectively as follows:
		\begin{equation}
			\begin{array}{l}
			<B_{0}, \textsf{Sign}_{S_{A}}(B_{0}),A_{11},\textsf{Sign}_{S_{A}}(A_{11}),A_{20},\textsf{Sign}_{S_{A}}(A_{20}),\textsf{Sign}_{S_{A}}(A_{\tau})>\\ 
				where\  A_{\tau} =\ <B_{0}||A_{11}||A_{20}>\\
			<C_{0}, \textsf{Sign}_{S_{A}}(C_{0}),A_{11},\textsf{Sign}_{S_{A}}(A_{11}),A_{20},\textsf{Sign}_{S_{A}}(A_{20}),\textsf{Sign}_{S_{A}}(A_{\tau})>\\ 
				where\  A_{\tau} =\ <C_{0}||A_{11}||A_{20}>
			\end{array}
		\end{equation}
		Once a vertex has received all the data-items of its off-path vertices, it can proceed to the verification step.
	
	\subsection{Verification of Inclusion}
	
		Once the sensor node has received all the data-items of its off-path vertices from its parent, first it verifies the signature of all the received data-items and then it verify that no aggregation result tampering has occurred on the path between its leaf vertex and the root of its commitment tree.
		And its senor reading was aggregated correctly by all the intermediate aggregate nodes.
		For each vertex on the path from the root of its commitment tree, it derives the data-items according to Definition \ref{def:label}.
		It is able to do so since the off-path values provide all the necessary information to perform the data-item computation.
		In the previous example, $C$ receives $B_{0}, A_{11}, A_{20}$ from its parent node and it has $C_{0}$.
		It aggregates $<C_{0}, B_{0}>$ and derives $A_{10}$.
		Then it aggregates $A_{10}, A_{11}$ and derives $A_{21}$.
		And finally it aggregates $A_{21}, A_{20}$ and derives $A_{3}$.
		Then it compares the derived $A_{3}$ with the $A_{3}$ received from the base station.
		Based on those data-items are identical or not the node proceeds with the next step accordingly.
		If those data-items are not identical then the node sends the authentication code with NACK message.
		And if those data-items are identical then the node sends the authentication code with ACK message.	

	\subsection{Collection of Authentication Codes}
		\label{subsection:collection-of-authentication-codes}
		The authentication codes for sensor node $S$, with their positive and negative acknowledgment message, are defined as follows:
		\begin{equation}
			\begin{array}{l}
				MAC_{S_{S}}(N || ACK)\\
				MAC_{S_{S}}(N || NACK)
			\end{array}
		\end{equation}

		\textcolor{red}{refactor-$S_{s}$ is the secret key of the sensor node $S$},	ACK, NACK are special messages for positive and negative acknowledgment respectively.
		The authentication code with ACK message is sent by the sensor node if it verifies its contribution correctly to the root commitment value during the \textit{verification of inclusion} phase and vice versa.
		Leaf sensor nodes in the aggregation tree first send their authentication codes to their parents in the aggregation tree.
		Once an internal sensor node has received authentication codes from all its children, it computes the XOR of its own authentication code with all the received codes, and forwards it to its parent.
		For example, the sensor node $B$ shown in Figure \ref{fig:Aggregation-tree-1}, receives the authentication codes $MAC_{S_{E}}(N||ACK)$, $MAC_{S_{F}}(N||ACK)$ from $E,F$ respectively, and it has its own authentication code with ACK message then $B$ sends the following authentication code to $A$.
			\begin{equation}
				MAC_{S_{E}}(N||ACK) \oplus MAC_{S_{F}}(N||ACK) \oplus MAC_{S_{B}}(N||ACK)
			\end{equation}
		Because of the XOR function we do not have to forward all the authentication codes. 
		At the end of the process, the base station receives a single authentication code $\Delta_{root}$\ from the root of an aggregation tree.
		% We can forward only one authentication code to the base station in the end, which consume the less bandwidth in the network.
		% Note that this phase is similar to the SHIA's collection of confirmation phase.

	\subsection{Verification of Authentication Codes}
		\label{sec:verficiation-of-authentication-codes}
		
		To verify that every sensor node has sent its authentication code with \ack, the base station computes the $\Delta_{ack}$ as follows:
		\begin{equation}
			\label{eq:mac-auth}
			\displaystyle{\Delta_{ack} = \bigoplus_{i = 1}^n MAC_{S_{i}}(N || ACK) }
		\end{equation}
		The base station can compute $\Delta_{ack}$ as it knows the secret key $S_{i}$\ for each sensor node $i$.
		Then it compares the computed $\Delta_{ack}$\ with the received root authentication code $\Delta_{root}$. 
		If those two codes match then it accepts the aggregated value or else it proceeds further to find an adversary. 

		To detect an adversary, the base station needs to identify which nodes in the aggregation tree sent its authentication codes with \nack\ during the verification of inclusion phase.
		The node who sent authentication code with \nack\ during the verification of inclusion phase is called a \complainer. 
		We claim that if there is a single complainer in the aggregation tree during the verification of inclusion phase then the base station can find the complainer in \textbf{linear time}.
		To find a complainer, the base station computes the complainer code $c$ as follows:
		\begin{equation}
			\label{eq:complainer}
			c := \Delta_{root} \oplus \Delta_{ack}
		\end{equation}
		Then it computes the complainer code $c_{i}$\ for all node $i = 1, 2, \dotsc, n$. 
		\begin{equation}
			\label{eq:caomplainer-node}
			c_{i} := MAC_{S_{i}}(N || ACK) \oplus MAC_{S_{i}}(N || NACK)
		\end{equation}
		After that, it compares $c$\ with all $c_{i}$\ one at a time. 
		And the matching code indicates the complainer node.
		The base station needs to do $n \choose 1$\ calculations according to Equation \ref{eq:caomplainer-node} and same number of comparisons to find a complainer in the aggregation tree. 
		Hence, the base station can find a single complainer in linear time.
		\begin{exmp} 
			If there are four nodes ${s_{1},s_{2},s_{3},s_{4}}$ in an aggregation tree and their authentication codes with \ack, \nack\ message in the binary format are defined as follows:
			\begin{equation}
				\begin{array}{l}
					\mac_{S_{1}}(N || \ack) = (1001)_{2};\ \mac_{S_{1}}(N || \nack) = (1101)_{2}\\
					\mac_{S_{2}}(N || \ack) = (0110)_{2};\ \mac_{S_{2}}(N || \nack) = (1111)_{2}\\	
					\mac_{S_{3}}(N || \ack) = (0101)_{2};\ \mac_{S_{3}}(N || \nack) = (0111)_{2}\\
					\mac_{S_{4}}(N || \ack) = (0011)_{2};\ \mac_{S_{4}}(N || \nack) = (1110)_{2}
				\end{array}
			\end{equation}
			Let's say the root of an aggregation tree computed the $\Delta_{root} = (0100)_{2}$ as described in Subsection \ref{subsection:collection-of-authentication-codes}.
			And the base station calculates $\Delta_{ack} = (1001)_{2}$ according to the Equation \ref{eq:mac-auth}.
			Then it calculates the complainer code $c = (1101)_{2}$ according to the Equation \ref{eq:complainer}.
			The base station also computes the complainer codes for each sensor node according to the Equation \ref{eq:caomplainer-node} as follows:
			\begin{equation}			
				c_{1} = (0100)_{2}, c_{2} = (1001)_{2}, c_{3} = (0010)_{2}, c_{4} = (1101)_{2}
			\end{equation}
			The base station compares complainer code $c$ with individual complainer code $c_{i}$ and finds that $c=c_{4}$.
			So, the base station identifies that the $s_{4}$\ complained, during verification of inclusion phase.
		\end{exmp}
		The binary illustration shows below helps visualize	\textcolor{red}{How applying XOR is negating the contribution of the authentication code with NACK?}
		The base station receives the following from the root an aggregation tree, which includes one authentication code with NACK.
		\[ 
			\left( 
				\begin{array}{cccc}
					1 & 0 & 0 & 1 \\ 
					0 & 1 & 1 & 0 \\
					0 & 1 & 0 & 1 \\
					1 & 1 & 1 & 0 \\
					\hline
					0 & 1 & 0 & 0 
				\end{array}
			\right)
		\]
		The base station calculates $\Delta_{ack}, \Delta_{nack} $ and complainer code $c$ as follows:
		\[ 
			\left( 
				\begin{array}{cccc}
					1 & 0 & 0 & 1 \\ 
					0 & 1 & 1 & 0 \\
					0 & 1 & 0 & 1 \\
					0 & 0 & 1 & 1 \\
					\hline
					1 & 0 & 0 & 1 
				\end{array}
			\right)
			\left( 
				\begin{array}{cccc}
					1 & 1 & 0 & 1 \\ 
					1 & 1 & 1 & 1 \\
					0 & 1 & 1 & 1 \\
					1 & 1 & 1 & 0 \\
					\hline
					1 & 0 & 1 & 1 
				\end{array}
			\right)
		\]
		\[ 
			\left( 
				\begin{array}{cccc}
					1 & 0 & 0 & 1 \\ 
					0 & 1 & 0 & 0 \\
					\hline
					1 & 1 & 0 & 1 \\
				\end{array}
			\right)
		\]
		Then the base station calculates the complainer code for each node $i$ as follows:
		\[
			\left( 
				\begin{array}{cccc cccc cccc cccc}
					1 & 0 & 0 & 1\ \vline\  0 & 1 & 1 & 0\ \vline\  0 & 1 & 0 & 1\ \vline\  0 & 0 & 1 & 1 \\
					1 & 1 & 0 & 1\ \vline\  1 & 1 & 1 & 1\ \vline\	0 & 1 & 1 & 1\ \vline\	1 & 1 & 1 & 0 \\ 
					\hline
					0 & 1 & 0 & 0\ \vline\ 1 & 0 & 0 & 1\ \vline\ 0 & 0 & 1 & 0\ \vline\ 1 & 1 & 0 & 1\\
				\end{array}
			\right)
		\]
		And concludes that node $4 $ is complaining.
		In general, to find $k$\ complainers the base station needs to do $ n \choose k$\ calculations and the same number of comparisons to find $k$\ complainers.

	\subsection{Detecting an adversary}
		Once the base station finds the node who send NACK during the verification of inclusion phase, it interacts with the nodes in the network to trace an adversary responsible for it. 
		The bases station utilizes the following algorithm to trace an adversary.

		\begin{algorithm}
		\caption{Pseudo algorithm to detect an adversary}
		\label{algo:detect-an-adversary}

			\begin{algorithmic}[1]

					\STATE $BS$ \ identifies all the complainer and creates $c = \{c_{1}, c_{2}, \dotsc, c_{n}\}$
					\FORALL {$N \in c$}

						\STATE $BS$\ asks $N$ to send data-items with its signature, sent during commitment tree generation phase
					
					\ENDFOR

					\STATE $BS$\ identifies possible adversary based on $c$ and creates $a = \{a_{1},a_{2},\dotsc,a_{n}\}$

					\FORALL {$A \in a$}

						\STATE $BS$\ asks $A$ to send data-items with its signature, received and sent by $A$ during commitment tree generation phase
						\STATE If needed $BS$\  asks the parent of $A$ to send data-items with its signature
			
					\ENDFOR

					\STATE $BS$\ determines the adversary based on the verification of signatures

			\end{algorithmic}
		\end{algorithm}

	\begin{theorem}
		%\emph{(Lagrange's Theorem)}
		\label{Commitment tree}
		Binary commitment tree is optimal in terms of verification as it requires minimum number of off-path values.
	\end{theorem}

	\begin{proof}
		Let us say $n$ is the number of leaves in the given commitment tree.

		$ \log _3( n ) = y $

		$ 3^y = n $

		$ \log_2( 3^y ) = \log_2( n ) $

		$ y * \log_2( 3 ) = \log_2( n ) $

		$ \log_3( n )*\log_2( 3 ) = \log_2( n ) $

		$ \log_3( n ) = \frac{ {\log _2 ( n )} }{{\log _2 ( 3 )}} $

		$ 2 * \log_3( n ) = [2 / \log_2( 3 ) ]* log_2( n ) = ( 1.2618 ) * log_2( n ) $

		$ 2 * log_3( n ) > log_2( n ) $ \\
		For the given binary commitment tree, each leaf vertex needs $\log_{2}(n)$ off-path values in the verification phase.
		The total off-path values needed in the given commitment tree is $n \cdot \log_{2}(n)$.\\
		For the given tertiary commitment tree, each leaf vertex needs $2 \cdot \log_{3}(n)$ off-path values in the verification phase.
		The total off-path values needed in given commitment tree is $2 \cdot n \cdot \log_{3}(n)$.

		Hence, in totality the binary commitment tree requires the minimum number of off-path values.
	\end{proof}

	\begin{theorem}
	\cite{chan2006secure}
	The Aggregate Commit with verification induces $O(\log^3 n)$ edge congestion. And $O(\delta\log^3 n)$ node congestion in the aggregation tree.
	\end{theorem}
	\begin{proof}
		While creating the commitment tree every sent message is at most $O(\log n)$ size.
		And while the off-path value dissemination step is the
	% dominating factor.
	% Consider an arbitrary edge in the commitment-tree between parent
	% vertex x and child vertex y. In the label dissemination step,
	% messages are only sent from parent to child in the commitment tree.
	% Hence the edge xy carries exactly the labels that y receives. From
	% Theorem 14, y receives O(logn) labels, hence the total number of
	% labels passing through xy is O(logn). Hence, the edge congestion
	% in the commitment tree is O(logn). Now consider an arbitrary aggregation
	% tree edge with parent node u and child node v. The child
	% node v presents (i.e., sends) at most logn commitment-tree vertices
	% to its parent u, and hence the edge uv is responsible for carrying
	% traffic on behalf of at most logn commitment-tree edges — these
	% are the edges incident on the commitment tree vertices that v presented
	% to u. Note that v may not be responsible for creating all
	% the vertices that it presents to u, but v is nonetheless responsible
	% for forwarding the messages down to the sensor nodes which created
	% those vertices. Since each edge in the commitment tree has
	% O(logn) congestion, and each edge in the aggregation tree carries
	% traffic for at most logn commitment-tree edges, the edge congestion
	% in the aggregation tree is O(log2 n). The node-congestion bound
	% of O(Δlog2 n) follows from the O(log2 n) edge congestion and the
	% definition of Δ as the greatest degree in the aggregation tree.
	\end{proof}


\section{Bandwidth Analysis}
	For any given sensor node's forest with $n$ leaf vertices, has at most $\log n$ data-items in its payload.
	It has at most $(\log n) +1$ signatures in its payload.
	The highest possible count value is $\log n$, as all the trees are binary. 

	An intermediate sensor node $S$ with $\beta$ descendants in the aggregation tree, has at most $\log(\beta+1)$ data-items with their respective $\log(\beta+1)$ signatures in its payload.
	$S$ might need to send its payload signature $Sign(S_{p})$.
	At max, $S$ has to send a payload with $\log(\beta+1)$ data-items and $\log(\beta+1) +1$ signatures to its parent in the aggregation tree.
	
	Hence, sending signatures of the data-items causes $O(\log \beta)$ bandwidth overhead for each node in the network, where $\beta$ is the number of descendants of the sensor node. 


\section{Performance Analysis}
	In addition to calculating its own data-items, all intermediate sensor nodes with $\beta$ descendants and $\zeta$ direct children need to do the following:
	\begin{itemize}
		\item To calculate and verify $O(\log \beta)$ signatures, creating $O(\log \beta)$ calculation overhead. 
		\item Needs sufficient memory to cache $O(\log \beta)$ certificates. 
		\item Needs enough memory to cache $\Omega(\zeta)$ certificates.
	\end{itemize}

	% Computation cost: Needs to calculate that many signatures. Needs to verify that many signatures.
	% Need to know that many certificates.

\section{Applications}
		The signature based aggregation scheme can be applied to do the \textbf{voting} in the network.
		And voting scheme can be used to solve many sensor network problems.
		For example, voting can be used to design the distributed algorithm for selecting a cluster head or node revocation system.
		In the voting scheme, following are the major security concerns: 
		\begin{itemize}
			\item The aggregate node needs to know that the vote is coming from the legit voter, no other voter is impersonating the vote of the legit voter.
			\item Only the intended aggregate node should be able to verify the vote.
			\item The aggregate node should not be able to tamper with the votes. 
			\item The aggregate node needs the proof that it aggregated the verified votes.
			\item The voter need the proof for which vote it sent to its aggregator.
		\end{itemize}
		For example, the base station wants to know the overall vote-count in the network.
		To do so, all the leaf nodes send their votes and the signature of their votes to their respective aggregate nodes in the network.
		The aggregate nodes receive votes with their signatures from all of their children voters.
		The aggregate nodes verify all the votes and count those votes.
		Then they forward the count and the signature of that count signed by the aggregate node to their respective parent in the aggregation tree.
		This process is repeated until the final count and its signature, is sent to the base station by the root of the aggregation tree.
				
\textbf{Node power level},
\textbf{Surveillance Application}
