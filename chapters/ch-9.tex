\chapter{Analysis}

% \section{Analysis}
	
	The following theorem proves that the complete binary tree structure is optimal for commitment tree generation.
	\begin{theorem}
		\label{the:ct}
		Binary commitment tree is optimal in terms of verification for $m$-ary tree, as it requires minimum number of off-path values.
	\end{theorem}

	\begin{proof}
		Consider the case of a tertiary tree, other $m$-ary tree arguments follows the same manner.
		Let $m$ be the number of leaves in a commitment tree.
		
		For the given binary commitment tree, each leaf vertex needs $\log_2 m$\ off-path values in the verification phase.
		The total off-path values needed in the given commitment tree is [${m \log_2 m}$].
		For the given tertiary commitment tree, each leaf vertex needs $2 \log_3 m$ off-path values in the verification phase.
		The total off-path values needed in given commitment tree is [$2 m \log_3 m$].
			\begin{equation*}
				\begin{array}{l}
					\mbox{Let}\  y = \log_3 m\\
					y = \frac{ {\log _2 m } }{{\log _2  3 }}\ \mbox{where}\ \log_2 3 > 1\\
					y \log_2 3 = \log _2 m \\
					\log_3 m \cdot \log_2 3 = \log _2 m \\
					\log_3 m = \frac{ {\log _2 m } }{{\log _2  3 }} \\
					2m\log_3 m = 2m\frac{ {\log _2 m } }{{\log _2  3 }} = \frac{ {2 } } {{\log _2  3 }}m\log _2 m \\
					2m\log_3 m = (1.2618)m\log _2 m \\
					2m\log_3 m > m\log _2 m \\

				\end{array}
			\end{equation*}
		Hence, in totality the binary commitment tree requires the minimum number of off-path values.
	\end{proof}

	\section{Bandwidth Analysis}

		Our protocol creates a complete binary tree for any given aggregation tree.
		Hence, if we have $n$ nodes in an aggregation tree, then at max there will be $2^{\lg n + 1} - 1 = 2n-1$ vertices in the commitment tree.

		In both the approaches FSwRD and FSwoRD, there are at least two signatures associated with all the vertices in the commitment tree.
		Hence, there are at least $2(2n-1)$ signatures created while creating the commitment tree.

		In general, an intermediate node with $n$ descendants receives $\lceil \log_2 n \rceil$ trees from its children.
		As we know, there are at least two signatures associated with each vertex, the node with $n$ descendants receives at least $2 \lceil \log_2 n \rceil $ signatures.

		We claim that the binary representation of a non-negative number $x$ illustrates the payload decomposition of the sensor node $S$, where $x$ = $1$ + number of descendants of $S$.
		For example, if sensor node $S$ has $22$ descendants then $x =23$, $(x)_{10}$ = $(10111)_{2}$. 
		This means $S$ has four complete binary trees in its payload, with the height of four, two, one and zero.
		Note that all the trees in the commitment payload are complete binary trees and no two trees have the same height.
		The reason $1$ is added to the descendants of $S$ is that the sensor node itself is collecting data.

		In both the approaches FSwRD and FSwoRD, the number of transmitted signatures within the network remain the same as shown in Table \ref{tab:analysis-table-1} (we ignore the signature of the payload ). 
		But the number of times a data-item is being signed differ in both the approaches which impacts the number of certificates being transmitted in the network.
		The certificate is large in size and consumes a lot of bandwidth during the transmission.
		To do the further analysis, we developed a performance matrix based on number of transmitted certificates for commonly used network topologies.
		We analyzed different network topologies as shown in Table \ref{tab:analysis-table-2}. 
		
		\begin{table}[!htb]
			\begin{center}
				\caption{Analysis Table 1}
				\label{tab:analysis-table-1}
				\begin{tabular}{|c||c|}
					\hline
					Network Topology & Totality of Signatures Transmitted \\ 
					\cline{2-2}
					 & FSwRD \mbox{   } \vline \mbox{   } FSwoRD \\
					\hline
					\hline
					Star & $2n$ \vline \mbox{   }$2n$ \\
					\hline
					Palm Tree & $2n$ \vline \mbox{   }$2n$\\
					\hline
					Complete Binary & $2n$ \vline \mbox{   }$2n$\\
					\hline
				\end{tabular}
			\end{center}
		\end{table}

		\begin{table}[!htb]
			\begin{center}
				\caption{Analysis Table 2}
				\label{tab:analysis-table-2}
				\begin{tabular}{|c||c|}
					\hline
					Network Topology & Totality of Certificates \\ 
					\cline{2-2}
					 & FSwRD \mbox{   } \vline \mbox{   } FSwoRD \\
					\hline
					\hline
					Star & $n - 1$ \vline \mbox{   }$n -1$ \\
					\hline
					Palm Tree & $XX$ \vline \mbox{   }$n - 1$\\
					\hline
					Complete Binary & $n - 1$ \vline \mbox{   }$n - 1$\\
					\hline
				\end{tabular}
			\end{center}
		\end{table}
		% \begin{table}[!htb]	
		% 	\begin{center}
		% 		\begin{tabular}{ |l| l| l| }
		% 	    \hline
		% 	    & FSwR & FSwoR \\
		% 	    \hline
		% 	    Number of created signatures & $2n + 1$ & $2n + 1$ \\	
		% 	    \hline
		% 	    Number of transmitted signatures & T & T\\
		% 	    \hline
		% 	    Number of signing activity & $2n + 1$ & $2n + 1$ \\
		% 	    \hline
		% 	    Number of verifying activity & $n - 1$ & $n - 1$ \\
		% 	    \hline
		% 	    Number of certificates & $n - 1$ & $n - 1$ \\
		% 	    \hline
		% 	    Edge congestion & $3(n - 1)$ & $3(n - 1)$\\
		% 	    \hline
		% 		\end{tabular}
		% 	\end{center}
	 %  		\caption{Analysis for Star Aggregation Tree}
		%  	\label{table:Analysis table for Star Aggregation Tree}
		% \end{table}

	 %  Table \ref{table:Analysis table for Palm Aggregation Tree} shows the analysis for the star tree network with $n$ nodes while creating the commitment tree.
		% \begin{table}[!htb]	
		% 	\begin{center}
		% 		\begin{tabular}{ |l| l| l| }
		% 	    \hline
		% 	    & FSwR & FSwoR \\
		% 	    \hline
		% 	    Number of created signatures & T & $2 (2^{\lg n + 1} - 1) + (n / 2)$ \\	
		% 	    \hline
		% 	    Number of transmitted signatures & T & T\\
		% 	    \hline
		% 	    Number of signing activity & T & T \\
		% 	    \hline
		% 	    Number of verifying activity & T & T \\
		% 	    \hline
		% 	    Number of certificates & T & T \\
		% 	    \hline
		% 	    Edge congestion & T & T\\
		% 	    \hline
		% 		\end{tabular}
		% 	\end{center}
	 %  	\caption{Analysis for Palm Aggregation Tree}
		%   \label{table:Analysis table for Palm Aggregation Tree}
	 %  \end{table}
		% As there are two signatures associated with any vertex in the commitment tree, there are at least  signatures created where $n$ is the number of nodes in the network.
		
		% Note that we send signatures while distributing off-path values as well.

		% If we throw away the old signatures and resign the data-item with current aggregate node then following is true:
		% 	\begin{itemize}
		% 		\item Each parent needs the certificates of only its direct children.
		% 		\item Each child needs to know the certificate of its parent only.
		% 		\item Number of signatures remain the same as previous approach.
		% 		\item Number of certificates needed in the network is $O(n)$; n is the number of nodes in the network.
		% 		\item We do not need the signature of the payload.
		% 	\end{itemize}



	% \begin{theorem}
	% \cite{chan2006secure}
	% The Aggregate Commit with verification induces $O(\log^3 n)$ edge congestion. And $O(\delta\log^3 n)$ node congestion in the aggregation tree.
	% \end{theorem}
	% \begin{proof}
	% 	While creating the commitment tree every sent message is at most $O(\log n)$ size.
	% 	And while the off-path value dissemination step is the
	% dominating factor.
	% Consider an arbitrary edge in the commitment-tree between parent
	% vertex x and child vertex y. In the label dissemination step,
	% messages are only sent from parent to child in the commitment tree.
	% Hence the edge xy carries exactly the labels that y receives. From
	% Theorem 14, y receives O(logn) labels, hence the total number of
	% labels passing through xy is O(logn). Hence, the edge congestion
	% in the commitment tree is O(logn). Now consider an arbitrary aggregation
	% tree edge with parent node u and child node v. The child
	% node v presents (i.e., sends) at most logn commitment-tree vertices
	% to its parent u, and hence the edge uv is responsible for carrying
	% traffic on behalf of at most logn commitment-tree edges — these
	% are the edges incident on the commitment tree vertices that v presented
	% to u. Note that v may not be responsible for creating all
	% the vertices that it presents to u, but v is nonetheless responsible
	% for forwarding the messages down to the sensor nodes which created
	% those vertices. Since each edge in the commitment tree has
	% O(logn) congestion, and each edge in the aggregation tree carries
	% traffic for at most logn commitment-tree edges, the edge congestion
	% in the aggregation tree is O(log2 n). The node-congestion bound
	% of O(Δlog2 n) follows from the O(log2 n) edge congestion and the
	% definition of Δ as the greatest degree in the aggregation tree.
	% \end{proof}

% \section{Bandwidth Analysis}
% 	For any given sensor node's forest with $n$ leaf vertices, has at most $\log n$ data-items in its payload.
% 	It has at most $(\log n) +1$ signatures in its payload.
% 	The highest possible count value is $\log n$, as all the trees are binary. 

% 	An intermediate sensor node $S$ with $\beta$ descendants in the aggregation tree, has at most $\log(\beta+1)$ data-items with their respective $\log(\beta+1)$ signatures in its payload.
% 	$S$ might need to send its payload signature $Sign(S_{p})$.
% 	At max, $S$ has to send a payload with $\log(\beta+1)$ data-items and $\log(\beta+1) +1$ signatures to its parent in the aggregation tree.
	
% 	Hence, sending signatures of the data-items causes $O(\log \beta)$ bandwidth overhead for each node in the network, where $\beta$ is the number of descendants of the sensor node. 

% \section{Performance Analysis}
% 	In addition to calculating its own data-items, all intermediate sensor nodes with $\beta$ descendants and $\zeta$ direct children need to do the following:
% 	\begin{itemize}
% 		\item To calculate and verify $O(\log \beta)$ signatures, creating $O(\log \beta)$ calculation overhead. 
% 		\item Needs sufficient memory to cache $O(\log \beta)$ certificates. 
% 		\item Needs enough memory to cache $\Omega(\zeta)$ certificates.
% 	\end{itemize}

% 	% Computation cost: Needs to calculate that many signatures. Needs to verify that many signatures.
% 	% Need to know that many certificates.

% \section{Applications}
% 		The signature based aggregation scheme can be applied to do the \textbf{voting} in the network.
% 		And voting scheme can be used to solve many sensor network problems.
% 		For example, voting can be used to design the distributed algorithm for selecting a cluster head or node revocation system.
% 		In the voting scheme, following are the major security concerns: 
% 		\begin{itemize}
% 			\item The aggregate node needs to know that the vote is coming from the legit voter, no other voter is impersonating the vote of the legit voter.
% 			\item Only the intended aggregate node should be able to verify the vote.
% 			\item The aggregate node should not be able to tamper with the votes. 
% 			\item The aggregate node needs the proof that it aggregated the verified votes.
% 			\item The voter need the proof for which vote it sent to its aggregator.
% 		\end{itemize}
% 		For example, the base station wants to know the overall vote-count in the network.
% 		To do so, all the leaf nodes send their votes and the signature of their votes to their respective aggregate nodes in the network.
% 		The aggregate nodes receive votes with their signatures from all of their children voters.
% 		The aggregate nodes verify all the votes and count those votes.
% 		Then they forward the count and the signature of that count signed by the aggregate node to their respective parent in the aggregation tree.
% 		This process is repeated until the final count and its signature, is sent to the base station by the root of the aggregation tree.
				
% \textbf{Node power level},
% \textbf{Surveillance Application}

% 	\begin{equation*}	
% 		\begin{array}{rl}
% 			\begin{array}{r}
% 				\\
% 				\\
% 				\\
% 				+\\

% 			\end{array}
% 			&
% 			\underbrace{
% 				% \left( 
% 					\begin{array}{cccc}
% 						1 & 0 & 0 & 1 \\ 
% 						0 & 1 & 1 & 0 \\
% 						0 & 1 & 0 & 1 \\
% 						0 & 0 & 1 & 1 \\
% 						\hline

% 					\end{array}
% 				% \right)
% 			}_{\Delta_{P}}
% 		\end{array}
% 	\end{equation*}