\chapter{Analysis}

% \section{Analysis}
	
	The following theorem proves that the complete binary tree structure is optimal for commitment tree generation.
	\begin{theorem}
		\label{Commitment tree}
		Binary commitment tree is optimal in terms of verification as it requires minimum number of off-path values.
	\end{theorem}

	\begin{proof}
		Let us say $n$ is the number of leaves in the given commitment tree.

		% \begin{equation*}
			
		%  \log _3( n ) = y 

		%  3^y = n 

		%  \log_2( 3^y ) = \log_2( n ) 

		%  y * \log_2( 3 ) = \log_2( n ) 

		%  \log_3( n )*\log_2( 3 ) = \log_2( n ) 

		%  \log_3( n ) = \frac{ {\log _2 ( n )} }{{\log _2 ( 3 )}} 

		%  2 * \log_3( n ) = [2 / \log_2( 3 ) ]* log_2( n ) = ( 1.2618 ) * log_2( n ) 

		%  2 * log_3( n ) > log_2( n )  \\
		% \end{equation*}
		For the given binary commitment tree, each leaf vertex needs $\log_{2}(n)$ off-path values in the verification phase.
		The total off-path values needed in the given commitment tree is $n \cdot \log_{2}(n)$.
		For the given tertiary commitment tree, each leaf vertex needs $2 \cdot \log_{3}(n)$ off-path values in the verification phase.
		The total off-path values needed in given commitment tree is $2 \cdot n \cdot \log_{3}(n)$.
		Hence, in totality the binary commitment tree requires the minimum number of off-path values.
	\end{proof}

	To do the analysis we developed a performance matrix. 
	We analysis different network topologies based on that matrix.
	% In both the approaches, the commitment tree is complete binary.
	% As we know, the complete binary tree has  $2^{h + 1} - 1$ vertices in the tree; where $h$ is the height of the tree with the root height is $0$. 
	% So, we need $\Omega(2^{h + 1} - 1)$ signatures in both the approaches. 
	% Analysis model:	
	% 	While creating CT;While distributing off-path; Both places together\\
	% Initial analysis says, if a single aggregate node cheats while CT generation or distributing off-path values it gets caught.

	As there are two signatures associated with any vertex in the commitment tree, there are at least $2 (2^{\lg n + 1} - 1)$ signatures created where $n$ is the number of nodes in the network.
	Table \ref{table:Analysis table for Star Aggregation Tree} shows the analysis for the star tree network with $n$ nodes while creating the commitment tree.
	\begin{table}[!htb]	
		\begin{center}
			\begin{tabular}{ |l| l| l| }
		    \hline
		    & FSwR & FSwoR \\
		    \hline
		    Number of created signatures & $2n + 1$ & $2n + 1$ \\	
		    \hline
		    Number of transmitted signatures & T & T\\
		    \hline
		    Number of signing activity & $2n + 1$ & $2n + 1$ \\
		    \hline
		    Number of verifying activity & $n - 1$ & $n - 1$ \\
		    \hline
		    Number of certificates & $n - 1$ & $n - 1$ \\
		    \hline
		    Edge congestion & $3(n - 1)$ & $3(n - 1)$\\
		    \hline
			\end{tabular}
		\end{center}
  	\caption{Analysis for Star Aggregation Tree}
	  \label{table:Analysis table for Star Aggregation Tree}
  \end{table}

  Table \ref{table:Analysis table for Palm Aggregation Tree} shows the analysis for the star tree network with $n$ nodes while creating the commitment tree.
	\begin{table}[!htb]	
		\begin{center}
			\begin{tabular}{ |l| l| l| }
		    \hline
		    & FSwR & FSwoR \\
		    \hline
		    Number of created signatures & T & $2 (2^{\lg n + 1} - 1) + (n / 2)$ \\	
		    \hline
		    Number of transmitted signatures & T & T\\
		    \hline
		    Number of signing activity & T & T \\
		    \hline
		    Number of verifying activity & T & T \\
		    \hline
		    Number of certificates & T & T \\
		    \hline
		    Edge congestion & T & T\\
		    \hline
			\end{tabular}
		\end{center}
  	\caption{Analysis for Palm Aggregation Tree}
	  \label{table:Analysis table for Palm Aggregation Tree}
  \end{table}
	As there are two signatures associated with any vertex in the commitment tree, there are at least  signatures created where $n$ is the number of nodes in the network.
	
	Note that we send signatures while distributing off-path values as well.

	If we throw away the old signatures and resign the data-item with current aggregate node then following is true:
		\begin{itemize}
			\item Each parent needs the certificates of only its direct children.
			\item Each child needs to know the certificate of its parent only.
			\item Number of signatures remain the same as previous approach.
			\item Number of certificates needed in the network is $O(n)$; n is the number of nodes in the network.
			\item We do not need the signature of the payload.
		\end{itemize}



	\begin{theorem}
	\cite{chan2006secure}
	The Aggregate Commit with verification induces $O(\log^3 n)$ edge congestion. And $O(\delta\log^3 n)$ node congestion in the aggregation tree.
	\end{theorem}
	\begin{proof}
		While creating the commitment tree every sent message is at most $O(\log n)$ size.
		And while the off-path value dissemination step is the
	% dominating factor.
	% Consider an arbitrary edge in the commitment-tree between parent
	% vertex x and child vertex y. In the label dissemination step,
	% messages are only sent from parent to child in the commitment tree.
	% Hence the edge xy carries exactly the labels that y receives. From
	% Theorem 14, y receives O(logn) labels, hence the total number of
	% labels passing through xy is O(logn). Hence, the edge congestion
	% in the commitment tree is O(logn). Now consider an arbitrary aggregation
	% tree edge with parent node u and child node v. The child
	% node v presents (i.e., sends) at most logn commitment-tree vertices
	% to its parent u, and hence the edge uv is responsible for carrying
	% traffic on behalf of at most logn commitment-tree edges — these
	% are the edges incident on the commitment tree vertices that v presented
	% to u. Note that v may not be responsible for creating all
	% the vertices that it presents to u, but v is nonetheless responsible
	% for forwarding the messages down to the sensor nodes which created
	% those vertices. Since each edge in the commitment tree has
	% O(logn) congestion, and each edge in the aggregation tree carries
	% traffic for at most logn commitment-tree edges, the edge congestion
	% in the aggregation tree is O(log2 n). The node-congestion bound
	% of O(Δlog2 n) follows from the O(log2 n) edge congestion and the
	% definition of Δ as the greatest degree in the aggregation tree.
	\end{proof}


\section{Bandwidth Analysis}
	For any given sensor node's forest with $n$ leaf vertices, has at most $\log n$ data-items in its payload.
	It has at most $(\log n) +1$ signatures in its payload.
	The highest possible count value is $\log n$, as all the trees are binary. 

	An intermediate sensor node $S$ with $\beta$ descendants in the aggregation tree, has at most $\log(\beta+1)$ data-items with their respective $\log(\beta+1)$ signatures in its payload.
	$S$ might need to send its payload signature $Sign(S_{p})$.
	At max, $S$ has to send a payload with $\log(\beta+1)$ data-items and $\log(\beta+1) +1$ signatures to its parent in the aggregation tree.
	
	Hence, sending signatures of the data-items causes $O(\log \beta)$ bandwidth overhead for each node in the network, where $\beta$ is the number of descendants of the sensor node. 


\section{Performance Analysis}
	In addition to calculating its own data-items, all intermediate sensor nodes with $\beta$ descendants and $\zeta$ direct children need to do the following:
	\begin{itemize}
		\item To calculate and verify $O(\log \beta)$ signatures, creating $O(\log \beta)$ calculation overhead. 
		\item Needs sufficient memory to cache $O(\log \beta)$ certificates. 
		\item Needs enough memory to cache $\Omega(\zeta)$ certificates.
	\end{itemize}

	% Computation cost: Needs to calculate that many signatures. Needs to verify that many signatures.
	% Need to know that many certificates.

\section{Applications}
		The signature based aggregation scheme can be applied to do the \textbf{voting} in the network.
		And voting scheme can be used to solve many sensor network problems.
		For example, voting can be used to design the distributed algorithm for selecting a cluster head or node revocation system.
		In the voting scheme, following are the major security concerns: 
		\begin{itemize}
			\item The aggregate node needs to know that the vote is coming from the legit voter, no other voter is impersonating the vote of the legit voter.
			\item Only the intended aggregate node should be able to verify the vote.
			\item The aggregate node should not be able to tamper with the votes. 
			\item The aggregate node needs the proof that it aggregated the verified votes.
			\item The voter need the proof for which vote it sent to its aggregator.
		\end{itemize}
		For example, the base station wants to know the overall vote-count in the network.
		To do so, all the leaf nodes send their votes and the signature of their votes to their respective aggregate nodes in the network.
		The aggregate nodes receive votes with their signatures from all of their children voters.
		The aggregate nodes verify all the votes and count those votes.
		Then they forward the count and the signature of that count signed by the aggregate node to their respective parent in the aggregation tree.
		This process is repeated until the final count and its signature, is sent to the base station by the root of the aggregation tree.
				
\textbf{Node power level},
\textbf{Surveillance Application}

	\begin{equation*}	
		\begin{array}{rl}
			\begin{array}{r}
				\\
				\\
				\\
				+\\

			\end{array}
			&
			\underbrace{
				% \left( 
					\begin{array}{cccc}
						1 & 0 & 0 & 1 \\ 
						0 & 1 & 1 & 0 \\
						0 & 1 & 0 & 1 \\
						0 & 0 & 1 & 1 \\
						\hline
						1 & 0 & 0 & 1 
					\end{array}
				% \right)
			}_{\Delta_{P}}
		\end{array}
	\end{equation*}