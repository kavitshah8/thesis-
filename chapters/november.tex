\chapter{november}

Various topics to write about:

\textit{Why do you want to communicate an entire aggregation tree to the querier ?}
	If the querier knows the entire aggregation tree and also if it knows the protocol which all the sensor nodes will be running then the querier can simulate the commitment trees on its own. Because of that we do not have to communicate the commitment tree every time we run the protocol which saves a lot of communications in the network. Also, note the fact that aggregation tree does not change often so the communication required to send the aggregation tree is negligible over time.

\textit{How to communicate an entire aggregation tree to the querier ?}
	The base station in the aggregation tree needs to know the entire network topology.
	It will relay that information to the querier.

\textit{How does the base station know the entire aggregation tree topology ?}
	If every sensor nodes has a small table containing the path to reach to the certain destination then the base station can ask for this information to the individual sensor nodes. While it is receiving this information it can relay the same information to the querier. Note: the base station is also a simple sensor node like all other nodes it can not store all the forwarding tables so it will relay those table information directly to the querier and querier can make big table containing the information related to the aggregation tree.
\textit{Mobility}
	You can talk about the aggregation tree topology is mobile. It's increasingly mobile technology not leap mobility.

\textit{Why does the internal vertex in the commitment tree need to send what it received and what it sent to its parent ?}
	
	To detect a cheater, if an internal vertex send ( to the querier ) only the values which it sent to its parent in the commitment tree then it is no value to the querier. Because the querier can not verify that value and the signature. For the querier to verify the aggregated data and its signature it needs both the values over which aggregation has happend. 

\textit{Why don't you need backward signatures ?}

\textit{Why do you need signatures on the forests ?}

\textit{Why being root in many trees add security to the protocol ?}

\textit{Why being root in many trees saves bandwidth ?}

\textit{Packet structure}

	$MESSAGE <ID, LABEL, SIGNATURE>$

	$ID <unique id of a node>$

	$LABEL <count, value, HASH(N||count||value)>$

	$SIGNATURE <E_{secretkey}(Message)>$

\textit{Why do we need authenticated broadcast from the querier ?}

\textit{Significance of Nonce}

\textit{Why do we need public key infrastructure ?}

\textit{Why don't we use aggregation tree as commitment tree ?}

\textit{Why is commitment tree binary ? (proof)}

\begin{algorithm}[H]
\caption {CommitmentTreeGeneration()}\label{number3}
	\begin {algorithmic}[1]
		\FORALL {$\node \in {\cal N}$}
			\STATE Create message and signature of that message and attach that to your forest
			\STATE If you have children then for all of your children do the following:
			\STATE Verify messages using its signature 
			\STATE If all the messages are verified true then merge the children with same count value (use some logic to resolve conflict) and create new node and attach that to your forest
		\ENDFOR
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Pseudo algorithm to detect a cheater}
	\begin{enumerate}
		\item The querier finds out the nodes who are complaining 
		\item The querier asks the complainer to send their reading \& signatures
		\item The querier finds possible cheaters based on complaines
		\item The querier asks possible cheaters to send the messages \& signatures they received and also the messages \& signatures they send. It can ask the complainers parents to do so.
		\item The querier determines the cheater. 
	\end{enumerate}

\end{algorithm}
