\chapter{november}

Various topics to write about:

\textit{Why do you want to communicate an entire aggregation tree to the querier ?}
	If the querier knows the entire aggregation tree and also if it knows the protocol which all the sensor nodes will be running then the querier can simulate the commitment trees on its own. Because of that we do not have to communicate the commitment tree every time we run the protocol which saves a lot of communications in the network. Also, note the fact that aggregation tree does not change often so the communication required to send the aggregation tree is negligible over time.

\textit{How to communicate an entire aggregation tree to the querier ?}
	The base station in the aggregation tree needs to know the entire network topology.
	It will relay that information to the querier.

\textit{How does the base station know the entire aggregation tree topology ?}
	If every sensor nodes has a small table containing the path to reach to the certain destination then the base station can ask for this information to the individual sensor nodes. While it is receiving this information it can relay the same information to the querier. Note: the base station is also a simple sensor node like all other nodes it can not store all the forwarding tables so it will relay those table information directly to the querier and querier can make big table containing the information related to the aggregation tree.

\textit{Mobility}
	You can talk about the aggregation tree topology is mobile. It's increasingly mobile topology not leap mobility.

\textit{Caching of certificates}
		Certificates are sent only once for the first time. They are cached for subsequent communications. Every node in the tree needs to know the certificates of all the root nodes in its forest.

\textit{Why does the internal vertex in the commitment tree need to send what it received and what it sent to its parent ?}
	To detect a cheater, if an internal vertex send ( to the querier ) only the values which it sent to its parent in the commitment tree then it is no value to the querier. Because the querier can not verify that value and the signature. For the querier to verify the aggregated data and its signature it needs both the values over which aggregation has happend. 

\textit{Why don't you need backward signatures ?} Because according to the protocol, every parent checks its children's message and its signature. If those two do not match then it will not accept the message.

\textit{Do you need signature on forest ? If yes, then why ? If no, then why ?}

\textit{Analyses of being root in as many tree as possible:}
	
	\begin{itemize}
		\item \textit{Bandwidth perspective}
	
			\textit{Off path values}
	
			\textit{Certificates}

		\item \textit{Security perspective}
	\end{itemize}

\textit{Packet structure}

	The message has the following structure:

	\begin{tabular}{ | l | l | l | l |}
		\hline
		ID & COUNT & VALUE & COMMITMENT\\
		\hline
	\end{tabular}

	The signature of the message is Encryption of Hash(Message) with its secret key.
	
\textit{Why do we need authenticated broadcast from the querier ?}

\textit{Significance of Nonce}

\textit{Why do we need public key infrastructure ?}

\textit{Why don't we use aggregation tree as commitment tree ?}

\textit{Why is commitment tree binary ? (proof)}

\begin{algorithm}[H]
\caption {CommitmentTreeGeneration}\label{number3}
	\begin {algorithmic}[1]
		\FORALL {$\node \in {\cal N}$}
			\STATE Create message and signature of that message and attach that to your forest
			\STATE If you have children then for all of your children do the following:
			\STATE Verify your childrens' messages using their signatures 
			\STATE If all the messages are verified true then merge the children with same count value (use some logic to resolve conflict) by creating a new node with its message and its signature 
			\STATE Attach that new node to your forest
		\ENDFOR
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Pseudo algorithm to detect a cheater}
	\begin{algorithmic}[1]
			\STATE The querier finds out the nodes who are complaining 
			\STATE The querier asks the complainer to send their reading \& signatures
			\STATE The querier finds possible cheaters based on complaines
			\STATE The querier asks possible cheaters to send the messages \& signatures they received and also the messages \& signatures they send. It can ask the complainers parents to do so.
			\STATE The querier determines the cheater. 
	\end{algorithmic}
\end{algorithm}


\textit{Properties of commitment tree and aggregation tree}


	If you have $O(n)$ descendents then you need $O(log(n))$ certificates \& signatures to verify the received messages.
	 
	If you have $O(n)$ children then you need $O(n)$ certificates \& signatures to verify the received messages.