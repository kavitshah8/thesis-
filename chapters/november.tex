\chapter{november}

Misc. topics to write about:

\textit{Why do you want to communicate an entire aggregation tree to the querier ?}
	If the querier knows the entire aggregation tree and also if it knows the protocol which all the sensor nodes will be running then the querier can simulate the commitment trees on its own. Because of that we do not have to communicate the commitment tree every time we run the protocol which saves a lot of communications in the network. Also, note the fact that aggregation tree does not change often so the communication required to send the aggregation tree is negligible over time.

\textit{How to communicate an entire aggregation tree to the querier ?}
	The base station in the aggregation tree needs to know the entire network topology.
	It will relay that information to the querier.

\textit{How does the base station know the entire aggregation tree topology ?}
	If every sensor nodes has a small table containing the path to reach to the certain destination then the base station can ask for this information to the individual sensor nodes. While it is receiving this information it can relay the same information to the querier. Note: the base station is also a simple sensor node like all other nodes it can not store all the forwarding tables so it will relay those table information directly to the querier and querier can make big table containing the information related to the aggregation tree.

\textit{Mobility}
	You can talk about the aggregation tree topology is mobile. It's increasingly mobile topology not leap mobility.

\textit{Caching of certificates}
		Certificates are sent only once for the first time. They are cached for subsequent communications. Every node in the tree needs to know the certificates of all the root nodes in its forest.

\textit{Why does the internal vertex in the commitment tree need to send what it received and what it sent to its parent ?}
	To detect a cheater, if an internal vertex send ( to the querier ) only the values which it sent to its parent in the commitment tree then it is no value to the querier. Because the querier can not verify that value and the signature. For the querier to verify the aggregated data and its signature it needs both the values over which aggregation has happend. 

\textit{Why don't you need backward signatures ?} Because according to the protocol, every parent checks its children's message and its signature. If those two do not match then it will not accept the message.

\textit{Do you need signature on forest ? If yes, then why ? If no, then why ?}

\textit{Analyses of being root in as many tree as possible:}
	
	\begin{itemize}
		\item \textit{Bandwidth perspective}
	
			\textit{Off path values}
				
				It takes same bandwidth (same hop counts) to distribute off path values in include itself or exclude itself stratergy. You can have inductive argument for it to prove it.

			\textit{Certificates}
				Parent node needs to deal with less nodes in the aggregation tree means it needs less certificates, means less memory storage. For example, in pseudo palm tree case if we use include it self streategy then it is possible that one node has to propagate its value from the bottom to the top of the tree. It means all the intermediate nodes need to know its certificate. This can be avoided by using exclude itself( being root in as many possible tree as possible ) stratergy.

		\item \textit{Security perspective}

				Exclude itself stratergy is more secure in the sense that aggregator needs to partner with two nodes to achieve cheating. If it includes itself then it has to partner with only one node which is relatively easy.

	\end{itemize}

\textit{Why do we need authenticated broadcast from the querier ?}

\textit{Significance of Nonce}

\textit{Why do we need public key infrastructure ?}

\textit{Why don't we use aggregation tree as commitment tree ?}

\textit{Why is commitment tree binary and not n-ary ? (proof)}

\textit{How to detect following cheating ?}
	The querier knows an aggregation tree and a protocol. So the querier can simulate commitment tree.
	All the nodes in the network are supposed to run the same protocol. Suppose if they don't then the commitment tree will look different. How will you detect such cheating ?

\begin{algorithm}[H]\label{number3} \caption {CommitmentTreeGeneration}
	\begin {algorithmic}[1]

		\STATE Starting with highest depth in decreasing order 

			\FORALL {\node \   $\in$ \aggregationTree }

					\STATE Create a \node.\msg, a \sign $_{\cal{N}}$(\node.\msg)
					\STATE Attach \node.\msg, a \sign $_{\cal{N}}$(\node.\msg) to \node.\forest

						\FORALL {\node.\children }

							\FORALL {\treeRoot \ $\in$ \children.\forest}

								\IF {\node \ has \treeRoot.\cert (else get \treeRoot.\cert )} 

										\STATE \node \ gets \treeRoot.\msg, \sign$_{\mathcal{R}}$(\treeRoot.\msg)

										\IF {\treeRoot.\msg \ is Verified by \node (else raise an alarm)}

											\STATE Add \treeRoot.\msg \ to \node.\forest
											\STATE Run Huffman coding like procedure on \node.\forest
										
										\ENDIF
								
								\ENDIF

							\ENDFOR

						\ENDFOR

			\ENDFOR

	\end{algorithmic}

\end{algorithm}

\begin{algorithm}
\caption{Pseudo algorithm to detect a cheater}

	\begin{algorithmic}[1]

			\STATE \querier \ finds out all the \complainer$_{\mathcal{N}}$ $\in$ \aggregationTree \ using a complainer detecting algorithm

			\FORALL {\complainer$_{\mathcal{N}}$}

				\STATE \querier \ gets \node$_{0}$, \sign $_{\cal{N}}$ ( \node$_{0}$ )
			
			\ENDFOR

			\STATE \querier \  finds possible \cheater \ based on \complainer$_{\mathcal{N}}$

			\FORALL {\cheater}

				\STATE \querier \  gets \node$_{\mathcal{I}}$, \sign $_{\cal{N}}$ ( \node$_{I}$ ) \cheater \  receives and sends. 
				\STATE If needed \querier \  gets \node$_{\mathcal{I}}$, \sign $_{\cal{N}}$ ( \node$_{I}$ ) of the \parent \ \cheater 
			
			\ENDFOR

			\STATE \querier \  determines the \cheater \ based on recived information

	\end{algorithmic}
\end{algorithm}

\textit{Properties of commitment tree and aggregation tree}

	If you have $O(n)$ children then you need atleast $\Omega(n)$ \& at max $O(nlog(n))$ certificates.

	If you have $O(n)$ descendents then you need $\Omega(log(n))$  \& at max $O(nlog(n))$ certificates.


\begin{theorem} \label{min certificates}
	Given an aggregation tree with N nodes, in totality network needs $\Omega(N)$ certificates.
\end{theorem}

\begin{proof}
	
	Let $T$ \ represent a node in an aggregation tree whose number of children are $T$.$CHILDREN$, $C$is one of its children and $P$ is its parent.\\
	We can say that $T$ needs certificates of all of its children because while creating a commitment tree $T$ receives at least one $C$.\msg \ and \sign$_{C}$ ($C$.\msg)  from all $T$.$CHILDREN$

	If your aggregation tree is such that $\forall T$ needs to send only one message to $P$ then every $P$ receives only $P.CHILDREN$ number of messages. Hence, $P$ needs $P.CHILDREN$ number of certificates.

	So, if every $P$ needs certificates only of its children  and we have N nodes in the network then since every node has a unique parent as aggregation tree is a rooted tree, in totality we need only N certificates in the network.

\end{proof}


\begin{theorem}
		Given an aggregation tree with N + 1 nodes, having $N_{i} = n_{i}!$ nodes at depth $d_{i}$, equally distributed among thier $n_{i-1}!$ parents then in totality network needs $\Omega(N)$ certificates.
\end{theorem}

\begin{proof}

	Let say we have N + 1 nodes in an aggregation tree, also $d_{i}$ represents depth at level i. Tree is constructed such that root has $n_{1}$ children, all $n_{1}$ nodes at $d_{1}$ have $n_{2}$ children, all ($n_{1} * n_{2}$)  nodes at $d_{2}$ have $n_{3}$ children and all ($n_{1} * n_{2} * n_{3} ... n_{n-1}$) nodes at $d_{n-1}$ have $n_{n}$ children.\\
	$ N + 1 = (1 + (n_{1}) + (n_{2} * (n_{1})) + (n_{3} * (n_{2} * n_{1})) + ... + (n_{n} * (n_{n-1} * n_{n-2} * n_{n-3} ... n_{1}) ) ) $\\
	
	All $ (n_{n-1} * n_{n-2} * n_{n-3} ... n_{1}) $ nodes at $ d_{n-1} $ need to know certificates of all of their $n_{n}$ children.
	If there is only one carry after aggregation then all nodes at $d_{n-1}$ need to send only one certificate to their parent.\\
	All $ (n_{n-2} * n_{n-3} * n_{n-4} ... n_{1}) $ nodes at $ d_{n-2} $ need to know certificates of all of their $ n-1 $ children.\\
	All $ n_{1} $ nodes at $ d_{1} $ need to know certificates of all of their $ n-2 $ children.\\
	The root need to know the certificates of all of its $ n_{1} $ children.\\
	Also, the querier needs to know the certificate of the root.\\
	So, in totality we need $ (1 + (n_{1}) + (n_{2} * (n_{1})) + (n_{3} * (n_{2} * n_{1})) + ... + (n_{n} * (n_{n-1} * n_{n-2} * n_{n-3} ... n_{1}) ) ) $ which is $\Omega(N)$. Hence, prooved.

\end{proof}

Tree properties \& notations

$d_{i}$ is the depth at $i$

$n_{i}$ is the fanout at $d_{i-1}$

$c_{i}$ is the number of certificates sent by each node at $d_{i}$
 												
 												$= \lceil log((n_{i+1} * c_{i+1}) + 1) \rceil$

$N_{i}$ is the number of nodes at $d_{i}$  

												$= \Pi_{k=1}^i n_k$

$T_{i}$ is the totality at $d_{i}$ where totality is the number of certificates received/needed
											
												$= N_{i} * (n_{i+1} * c_{i+1})$

Total number of nodes in a tree  
												
												$= N + 1$
												
												$= N_{0} + N_{1} + N_{2} + + N_{3} + ... + N_{n-2} + N_{n-1} + N_{n}$
												
												$= n_{0}! + n_{1}! + n_{2}! + n_{3}! + ...	+ n_{n-2}!  + n_{n-1}! + n_{n}!$
												
												$= 1 + n_{1}! + n_{2}! + n_{3}! + ...	+ n_{n-2}!  + n_{n-1}! + n_{n}!$

\begin{theorem}
	Given an aggregation tree with N + 1 nodes, having $N_{i} = n_{i}!$ nodes at depth $d_{i}$, equally distributed among thier $n_{i-1}!$ parents then in totality network needs $O(N*log(C))$ certificates where $C$ is a constant.
\end{theorem}

\begin{proof}
	
	Case I: For $d_{n}\ ; N_{n} = n_{n}!\ ; T_{n} = 0\ ; c_{n} = 1 $\\
	Case II: For $d_{n - 1}\\ N_{n - 1} = n_{n - 1}!\\ T_{n - 1} = n_{n - 1}! * (n_{n} * c_{n}) = n_{n - 1}! * (n_{n} )\\ c_{n - 1} = 2\\ $
	Case III: For $d_{n - 2}\\ N_{n - 2} = n_{n - 2}!\\ T_{n -2} = n_{n - 2}! * (n_{n - 1} * c_{n - 1}) = n_{n - 2}! * (n_{n - 1 } * 2) \\ c_{n - 2} = \lceil log((n_{n - 1} *c_{n - 1}) + 1) \rceil = \lceil log((n_{n - 1} * 2) + 1) \rceil $\\
	Case IV: For $d_{n - 3}\\ N_{n - 3} = n_{n - 3}!\\ T_{n -3} = n_{n - 3}! * (n_{n - 2} * c_{n - 2}) = n_{n - 3}! * (n_{n - 2 } * \lceil log((n_{n - 1} * 2 ) + 1) \rceil ) \\ c_{n - 3} = \lceil log((n_{n - 2} * c_{n - 2}) + 1) \rceil = \lceil log( n_{n - 2} *\lceil log((n_{n - 1} * 2 ) + 1) \rceil + 1) \rceil $\\
\end{proof}

\begin{theorem}
		Given an aggregation tree with N + 1 nodes, having $N_{i} = n_{i}!$ nodes at depth $d_{i}$, equally distributed among thier $n_{i-1}!$ parents then in totality network needs $\Omega(N)$ certificates.
\end{theorem}

\begin{proof}

	Case I: For $d_{n}\ ; N_{n} = n_{n}!\ ; T_{n} = 0\ ; c_{n} = 1 $\\
	Case II: For $d_{n - 1}\\ N_{n - 1} = n_{n - 1}!\\ T_{n - 1} = n_{n - 1}! * (n_{n} * c_{n}) = n_{n - 1}! * n_{n}\\ c_{n - 1} = 1\\ $
	Case III: For $d_{n - 2}\\ N_{n - 2} = n_{n - 2}!\\ T_{n -2} = n_{n - 2}! * (n_{n - 1} * c_{n - 1}) = n_{n - 2}! * n_{n - 1 } \\ c_{n - 2} = 1$\\
	Case IV: For $d_{n - 3}\\ N_{n - 3} = n_{n - 3}!\\ T_{n -3} = n_{n - 3}! * (n_{n - 2} * c_{n - 2}) = n_{n - 3}! * n_{n - 2 } \\$     $c_{n - 3} = 1$\\ \\
	Case n-2: For $d_{2}\\ N_{2} = n_{2}!\\ T_{2} = n_{2}! * (n_{3} * c_{3}) = n_{2}! * n_{3} \\$  $c_{2} = 1$\\
	Case n-1: For $d_{1}\\ N_{1} = n_{1}!\\ T_{1} = n_{1}! * (n_{2} * c_{2}) = n_{1}! * n_{2} \\$  $c_{n-1} = 1$\\

\end{proof}


Things discuss:\\
	Every node does the same thing\\
	Individual throughput for each node\\

With n(= 4) bit forest, uniform children distribution and fanout of 2, savings of n certificates (can increase n = 4 to n = n to achieve maximum savings):

\begin{multicols}{2}

	\begin{tabular}{ l | l l c r }
	  1 & 1 & 1 & 1 & 0 \\
	  \hline
	  0 & 1 & 1 & 1 & 1 \\
	  0 & 1 & 1 & 1 & 1 \\
	  0 & 0 & 0 & 0 & 1 \\
	  \hline	
	  A & C & C & C & C\\
	\end{tabular}
\columnbreak{|}
	\begin{tabular}{ l | l l c r }
	  1 & 1 & 1 & 1 & 0 \\
	  \hline
	  0 & 1 & 1 & 1 & 1 \\
	  0 & 1 & 1 & 1 & 1 \\
	  0 & 0 & 0 & 0 & 1 \\
	  \hline	
	  A & A & A & A & A\\
	\end{tabular}
\end{multicols}

With n(= 4) bit forest, uniform children distribution and fanout of 3, savings of n - 1 certificates :

\begin{multicols}{2}

	\begin{tabular}{ l l |l l c r }
	  0 & 1 & 1 & 1 & 1 & 0 \\
	  1 & 1 & 1 & 1 & 1 & 0 \\
	  \hline
	  0 & 0 & 1 & 1 & 1 & 1 \\
	  0 & 0 & 1 & 1 & 1 & 1 \\
	  0 & 0 & 1 & 1 & 1 & 1 \\
	  0 & 0 & 0 & 0 & 0 & 1 \\
	  \hline	
	  A & 0 & C & C & C & 0 \\
	\end{tabular}
\columnbreak{|}
	\begin{tabular}{ l l | l l c r }
	  0 & 1 & 1 & 1 & 1 & 0 \\
	  1 & 1 & 1 & 1 & 1 & 0 \\
	  \hline
	  0 & 0 & 1 & 1 & 1 & 1 \\
	  0 & 0 & 1 & 1 & 1 & 1 \\
	  0 & 0 & 1 & 1 & 1 & 1 \\
	  0 & 0 & 0 & 0 & 0 & 1 \\
	  \hline
	  A & 0 & A & A & A & 0\\

	\end{tabular}

\end{multicols}

With n(= 4) bit forest, uniform children distribution and fanout of 4, savings of n - 1 certificates :

\begin{multicols}{2}

	\begin{tabular}{ l l |l l c r }
	  
	  0 & 1 & 1 & 1 & 0 & 0 \\
	  0 & 1 & 1 & 1 & 1 & 0 \\
	  1 & 1 & 1 & 1 & 1 & 0 \\
	  \hline
	  0 & 0 & 1 & 1 & 1 & 1 \\
	  0 & 0 & 1 & 1 & 1 & 1 \\
	  0 & 0 & 1 & 1 & 1 & 1 \\
	  0 & 0 & 1 & 1 & 1 & 1 \\
	  0 & 0 & 0 & 0 & 0 & 1 \\
	  \hline	
	  A & A & C & C & 0 & C \\
	
	\end{tabular}
\columnbreak{|}
	\begin{tabular}{ l l | l l c r }
	  0 & 1 & 1 & 1 & 0 & 0 \\
	  0 & 1 & 1 & 1 & 1 & 0 \\
	  1 & 1 & 1 & 1 & 1 & 0 \\
	  \hline
	  0 & 0 & 1 & 1 & 1 & 1 \\
	  0 & 0 & 1 & 1 & 1 & 1 \\
	  0 & 0 & 1 & 1 & 1 & 1 \\
	  0 & 0 & 1 & 1 & 1 & 1 \\
	  0 & 0 & 0 & 0 & 0 & 1 \\
	  \hline
	  A & A & A & A & 0 & A\\

	\end{tabular}

\end{multicols}

With n(= 4) bit forest, uniform children distribution and fanout of 2 \& 3, No savings :

\begin{multicols}{2}

	\begin{tabular}{ l |l l c r }
	  
	  1 & 0 & 1 & 0 & 0 \\
	  \hline
	  0 & 1 & 0 & 1 & 0 \\
	  0 & 1 & 0 & 1 & 0 \\
	  0 & 0 & 0 & 0 & 1 \\
	  \hline	
	  A & 0 & A & 0 & A \\
	
	\end{tabular}
\columnbreak{|}
	\begin{tabular}{ l |l l c r }
	  
	  1 & 0 & 1 & 0 & 0 \\
	  \hline
	  0 & 1 & 0 & 1 & 0 \\
	  0 & 1 & 0 & 1 & 0 \\
	  0 & 1 & 0 & 1 & 0 \\
	  0 & 0 & 0 & 0 & 1 \\
	  \hline	
	  A & C & A & C & A \\
	
	\end{tabular}

\end{multicols}

Meeting:

	Find cases where you can say it will be always A's.
	Analyze palm tree / pseudo palm tree 