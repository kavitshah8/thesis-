\chapter{Verification}

\section{dissemination final commitment}
\section{dissemination of off-path values}
\section{verification of inclusion}
\section{collection of authentication codes}
\section{verification of authentication codes}
	The authentication codes for sensor node $s$, with either positive or negative acknowledgment message, are defined as follows:
	\begin{equation}
		MAC_{K_{s}}(N\ ||\ \textit{ACK})
	\end{equation}
	\begin{equation}
		MAC_{K_{s}}(N\ ||\ \textit{NACK})
	\end{equation}
	$K_{s}$ is the key that $s$ shares with the base station;
	$\textit{ACK}$, $\textit{NACK}$ are special messages for positive and negative acknowledgment respectively.
	The authentication code with $\textit{ACK}$ message is sent by the sensor node if it verifies its contribution correctly to the root commitment value during the 
	\textit{verification of inclusion} phase and vice versa.
	
	To verify that every sensor node has sent its authentication code with \ack, the base station computes the $MAC_{root}(ACK)$ as follows.
	\begin{equation}
		\resizebox{.9\hsize}{!} 
		{$MAC_{root}(ACK) = MAC_{K_{1}}(N\ ||\ \textit{ACK}) \oplus MAC_{K_{2}}(N\ ||\ \textit{ACK}) \oplus \dotsc \oplus MAC_{K_{n}}(N\ ||\ \textit{ACK})$}
	\end{equation}
	The base station can compute $MAC_{root}(ACK)$ as it knows $K_{s}$\ for each sensor node $s$.
	Then it compares the computed $MAC_{root}(ACK)$\ with the received root authentication code $MAC_{root}$\ from the root of the aggregation tree. 
	If those two codes match then it accepts the aggregated value or else it proceeds further to find an adversary. 

	To detect an adversary, the base station needs to identify which nodes in the aggregation tree sent its authentication codes with \nack\ during the verification of inclusion phase.
	The node who sent authentication code with \nack\ during the verification of inclusion phase is called \complainer. 
	We claim that if there is only one complainer in the aggregation tree during the verification of inclusion phase then the base station can find the complainer in linear time.

	\begin{equation}
		\resizebox{.9\hsize}{!} 
		{$MAC_{root}(\textit{NACK}) = MAC_{K_{1}}(N\ ||\ \textit{NACK}) \oplus MAC_{K_{2}}(N\ ||\ \textit{NACK}) \oplus \dotsc \oplus MAC_{K_{n}}(N\ ||\ \textit{NACK})$}
	\end{equation}
	$\forall i \in [1,n]$
	\begin{equation}
		c_{i} = MAC_{K_{i}}(N\ ||\ \textit{ACK}) \oplus MAC_{K_{i}}(N\ ||\ \textit{NACK})
	\end{equation}
	At the end of the \textit{collection of authentication codes} phase, the base station receives single authentication code $MAC_{root}$ from the root of the aggregation tree. Once the base station receives the $MAC_{root}$ it calculates the following:
	\begin{equation}
		c = MAC_{root} \oplus MAC_{root}(ACK)
	\end{equation}
	If there is only one complainer in the aggregation tree, then the value of $c$ must match one of the values of $c_{1}$, $c_{2}$, $\dotsc$, $c_{n}$.
	As $MAC_{root}$ contains only one authentication code with $\textit{NACK}$\ message $XOR$ing $MAC_{root}(ACK)$\ negates all the authentication codes with positive acknowledgment messages. 
	Hence, $c$ is the $XOR$ of authentication codes with positive and negative acknowledgment messages of the complainer.
	The matching value node is the complainer.The base station needs to do $n$ comparison to find a complainer in the aggregation tree. So, the base station can find the complainer in linear time.

	\[ 
		\left( 
			\begin{array}{cccc}
				1 & 0 & 0 & 1 \\ 
				0 & 1 & 1 & 0 \\
				0 & 1 & 0 & 1 \\
				0 & 0 & 1 & 1 \\
				\hline
				1 & 0 & 0 & 1 
			\end{array}
		\right)
	%
		\left( 
			\begin{array}{cccc}
				1 & 1 & 0 & 1 \\ 
				1 & 1 & 1 & 1 \\
				0 & 1 & 1 & 1 \\
				1 & 1 & 1 & 0 \\
				\hline
				1 & 0 & 1 & 1 
			\end{array}
		\right)
	\]

	The base station receives the following:
	\[ 
		\left( 
			\begin{array}{cccc}
				1 & 0 & 0 & 1 \\ 
				0 & 1 & 1 & 0 \\
				0 & 1 & 0 & 1 \\
				1 & 1 & 1 & 0 \\
				\hline
				0 & 1 & 0 & 0 
			\end{array}
		\right)
	\]

	The base station does the following:

	\[
		\left( 
			\begin{array}{cccc cccc cccc cccc}
				1 & 0 & 0 & 1\ \vline\  0 & 1 & 1 & 0\ \vline\  0 & 1 & 0 & 1\ \vline\  0 & 0 & 1 & 1 \\
				1 & 1 & 0 & 1\ \vline\  1 & 1 & 1 & 1\ \vline\	0 & 1 & 1 & 1\ \vline\	1 & 1 & 1 & 0 \\ 
				\hline
				0 & 1 & 0 & 0\ \vline\ 1 & 0 & 0 & 1\ \vline\ 0 & 0 & 1 & 0\ \vline\ 1 & 1 & 0 & 1\\
			\end{array}
		\right)
	\]

	\[ 
		\left( 
			\begin{array}{cccc}
				1 & 0 & 0 & 1 \\ 
				0 & 1 & 0 & 0 \\
				\hline
				1 & 1 & 0 & 1 \\
			\end{array}
		\right)
	\]

	And concludes that node $4 $ is complaining.

\section{Detect an adversary}