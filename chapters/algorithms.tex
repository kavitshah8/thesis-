\chapter{algorithms}

	\textit{MESSAGE}
	\newline
	
	\begin{tabular}{ | l | l | l | l |}
		\hline
		ID & COUNT & VALUE & COMMITMENT \\
		\hline
		20 bits & 21 bits & 20 bits & 256 bits\\
		\hline
	\end{tabular}
	\newline
	\newline
	\textit{SIGNATURE (MESSAGE)}
	\newline

	\begin{tabular}{ |l| }
		\hline
		Encryption$_{secret-key_{node}}$( HASH ( MESSAGE ) )\\
		\hline
		500 bits\\
		\hline
	\end{tabular}
	\newline
	\newline
	\textit{CERTIFICATES}
	\newline

	\begin{tabular}{ | l | l | l | }
		\hline
			Public key  & Signature & ID \\
		\hline
			1000 bits & 500 bits & 20 bits \\
		\hline

	\end{tabular}

	\newpage

\begin{algorithm}[H]\label{number3} \caption {CommitmentTreeGeneration}
	\begin {algorithmic}[1]

		\STATE depth = $MAXDEPTH$
		\WHILE {depth $\geq$ 0}

			\FORALL {\node \   $\in$ \aggregationTree.depth }

					\STATE Create \node.\msg, \sign $_{\cal{N}}$(\node.\msg)
					\STATE Attach \node.\msg, \sign $_{\cal{N}}$(\node.\msg) to \node.\forest

						\FORALL {$x$ $\in$ \node.\children }

							\FORALL {tree root \treeRoot \ $\in$ $x$.\forest}

								\IF {\node \ has \treeRoot.\cert (else get \treeRoot.\cert )} 

										\STATE \node \ gets \treeRoot.\msg, \sign$_{\mathcal{R}}$(\treeRoot.\msg)

										\IF {\treeRoot.\msg \ is Verified by \node (else raise an alarm)}

											\STATE Add \treeRoot \ to \node.\forest
											\STATE Call subroutine Kavit Coding
										
										\ENDIF
								
								\ENDIF

							\ENDFOR

						\ENDFOR
			
					\STATE {depth = depth - 1 }

			\ENDFOR

	\ENDWHILE
	\end{algorithmic}

\end{algorithm}

\begin{algorithm}[H]\caption{Kavit Coding}
\end{algorithm}

\newpage

\begin{algorithm}
\caption{Pseudo algorithm to detect a cheater}

	\begin{algorithmic}[1]

			\STATE \querier \ finds out all the \complainer$_{\mathcal{N}}$ $\in$ \aggregationTree \ using a complainer detecting algorithm

			\FORALL {\complainer$_{\mathcal{N}}$}

				\STATE \querier \ gets \node$_{0}$, \sign $_{\cal{N}}$ ( \node$_{0}$ )
			
			\ENDFOR

			\STATE \querier \  finds possible \cheater \ based on \complainer$_{\mathcal{N}}$

			\FORALL {\cheater}

				\STATE \querier \  gets \node$_{\mathcal{I}}$, \sign $_{\cal{N}}$ ( \node$_{I}$ ) \cheater \  receives and sends. 
				\STATE If needed \querier \  gets \node$_{\mathcal{I}}$, \sign $_{\cal{N}}$ ( \node$_{I}$ ) of the \parent \ \cheater 
			
			\ENDFOR

			\STATE \querier \  determines the \cheater \ based on recived information

	\end{algorithmic}
\end{algorithm}

\textit{Properties of commitment tree and aggregation tree}

	If you have $O(n)$ children then you need atleast $\Omega(n)$ \& at max $O(nlog(n))$ certificates.

	If you have $O(n)$ descendents then you need $\Omega(log(n))$  \& at max $O(nlog(n))$ certificates.
